<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="java学习笔记"><meta name="keywords" content="java"><meta name="author" content="GCS-ZHN,undefined"><meta name="copyright" content="GCS-ZHN"><title>java学习笔记【潇洒记忆】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><link rel="icon" href="/favicon.ico"><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- script(src=url_for("/js/mathjax/mathjax.js"))--><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  gitment: {},
  valine: {},
}</script><meta name="generator" content="Hexo 6.0.0"></head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="toggle-sidebar-info button-hover"><span data-toggle="文章目录">站点概览</span></div><div class="sidebar-toc"><div class="sidebar-toc-title">目录</div><div class="sidebar-toc-progress"><span class="progress-notice">您已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc-progress-bar"></div></div><div class="sidebar-toc-content" id="sidebar-toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81JavaDoc"><span class="toc-number">1.</span> <span class="toc-text">一、JavaDoc</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 注意点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E4%B8%8ELambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">二、函数式接口与Lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-java-8-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E6%A6%82%E8%BF%B0"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 java 8 函数式接口概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 函数式接口的自定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 Lambda表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-Java-%E7%BB%8F%E5%85%B8%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 Java  经典函数式接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-Java%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E8%BA%AB%E5%BD%B1"><span class="toc-number">2.5.</span> <span class="toc-text">2.5 Java标准库中的应用身影</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%89%B9%E6%AE%8A%E5%BD%A2%E5%BC%8F"><span class="toc-number">2.6.</span> <span class="toc-text">2.6 Lambda表达式的特殊形式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81Java%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="toc-number">3.</span> <span class="toc-text">三、Java线程基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-synchronized%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 synchronized关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-wait%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 wait方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-notify%E6%96%B9%E6%B3%95"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 notify方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-notifyAll%E6%96%B9%E6%B3%95"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 notifyAll方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-sleep%E6%96%B9%E6%B3%95"><span class="toc-number">3.5.</span> <span class="toc-text">3.5 sleep方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-yield%E6%96%B9%E6%B3%95"><span class="toc-number">3.6.</span> <span class="toc-text">3.6 yield方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-join%E6%96%B9%E6%B3%95"><span class="toc-number">3.7.</span> <span class="toc-text">3.7 join方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java-util-concurrent-locks-Lock%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.8.</span> <span class="toc-text">java.util.concurrent.locks.Lock接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Java%E6%B3%9B%E5%9E%8B%EF%BC%88generics%EF%BC%89%E6%B5%85%E6%B6%89"><span class="toc-number">4.</span> <span class="toc-text">四、Java泛型（generics）浅涉</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E6%B3%9B%E5%9E%8B%E5%A3%B0%E6%98%8E"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 泛型声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 泛型通配符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 类型擦除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81Java%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%8A%80%E6%9C%AF"><span class="toc-number">5.</span> <span class="toc-text">五、Java序列化与反序列化技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 序列化与反序列化的过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81java%E6%B3%A8%E8%A7%A3"><span class="toc-number">6.</span> <span class="toc-text">六、java注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E3%80%81java%E5%8F%8D%E5%B0%84"><span class="toc-number">7.</span> <span class="toc-text">七、java反射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB%E3%80%81java%E5%86%85%E7%BD%AE%E6%95%B0%E7%BB%84"><span class="toc-number">8.</span> <span class="toc-text">八、java内置数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%9D%E3%80%81java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%B0%81%E8%A3%85"><span class="toc-number">9.</span> <span class="toc-text">九、java基本数据类型的封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E3%80%81java-native-interface%EF%BC%88JNI%EF%BC%89%E6%8E%A5%E5%8F%A3"><span class="toc-number">10.</span> <span class="toc-text">十、java native interface（JNI）接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81class%E6%96%87%E4%BB%B6"><span class="toc-number">11.</span> <span class="toc-text">十一、class文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81java%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4%E4%BA%A4%E4%BA%92"><span class="toc-number">12.</span> <span class="toc-text">十二、java与操作系统命令交互</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-1-Runtime-getRuntime-exec"><span class="toc-number">12.1.</span> <span class="toc-text">12.1 Runtime.getRuntime().exec</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-2-ProcessBuilder"><span class="toc-number">12.2.</span> <span class="toc-text">12.2 ProcessBuilder</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E4%B8%89%E3%80%81%E5%A5%BD%E7%94%A8%E7%9A%84%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93"><span class="toc-number">13.</span> <span class="toc-text">十三、好用的第三方库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1-Lomdok%E6%8F%92%E4%BB%B6"><span class="toc-number">13.1.</span> <span class="toc-text">13.1 Lomdok插件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-fastjson"><span class="toc-number">13.2.</span> <span class="toc-text">13.2 fastjson</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-3-jsch"><span class="toc-number">13.3.</span> <span class="toc-text">13.3 jsch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-4-velocity"><span class="toc-number">13.4.</span> <span class="toc-text">13.4 velocity</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-5-jedis"><span class="toc-number">13.5.</span> <span class="toc-text">13.5 jedis</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-6-druid"><span class="toc-number">13.6.</span> <span class="toc-text">13.6 druid</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM"><span class="toc-number">14.</span> <span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JVM%E5%8F%82%E6%95%B0"><span class="toc-number">14.1.</span> <span class="toc-text">JVM参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#try-%E8%AF%AD%E5%8F%A5%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE"><span class="toc-number">15.</span> <span class="toc-text">try 语句资源释放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="toc-number">16.</span> <span class="toc-text">参考文献</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/avatar.png"></div><div class="author-info-name">GCS-ZHN</div><div class="author-info-description"></div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/GCS-ZHN" target="_blank">GitHub<i class="icon-dot bg-color9"></i></a><a class="links-button button-hover" href="mailto:zhang.h.n@foxmail.com" target="_blank">E-Mail<i class="icon-dot bg-color4"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/archives"><span class="pull-top">日志</span><span class="pull-bottom">36</span></a><a class="author-info-articles-tags article-meta" href="/tags"><span class="pull-top">标签</span><span class="pull-bottom">65</span></a><a class="author-info-articles-categories article-meta" href="/categories"><span class="pull-top">分类</span><span class="pull-bottom">22</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/archives">归档</a></nav><div class="right-info"><a class="title-name" href="/">潇洒记忆</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="title">java学习笔记</div><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 发表于 2022-03-10 | 更新于 2025-02-19</time><!--time.button-hover.post-date #[i.fas.fa-calendar-alt.article-icon(aria-hidden="true")] #[=__('post.modified')] #[=date(page['updated'], config.date_format)]--><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/java/">java</a></div></div></div><div class="main-content"><h3 id="一、JavaDoc"><a href="#一、JavaDoc" class="headerlink" title="一、JavaDoc"></a>一、JavaDoc</h3><p>javadoc是为java开发者提供程序注释工具，通过采用规范的javadoc语法对java源码进行注释，并利用提供的javadoc工具快速生成标准的javadoc文档。当其他人使用开发者发布的工具包时，可以通过javadoc文档阅读，快速学习了解相应的应用程序接口（api）。</p>
<h4 id="1-1-注意点"><a href="#1-1-注意点" class="headerlink" title="1.1 注意点"></a>1.1 注意点</h4><p>javadoc默认Console输出编码采用系统默认，在涉及中文编码时会产生乱码，通过配置环境变量<code>JAVA_TOOL_OPTIONS=--Dfile.encoding=UTF-8</code>解决</p>
<h3 id="二、函数式接口与Lambda表达式"><a href="#二、函数式接口与Lambda表达式" class="headerlink" title="二、函数式接口与Lambda表达式"></a>二、函数式接口与Lambda表达式</h3><h4 id="2-1-java-8-函数式接口概述"><a href="#2-1-java-8-函数式接口概述" class="headerlink" title="2.1 java 8 函数式接口概述"></a>2.1 java 8 函数式接口概述</h4><p>函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口, 其用<code>@FunctionalInterface</code>标注。可以由Lambda表达式转化创建。这种接口一般用于功能的自定义实现。在Java 8以前，想要达到目的必须使用接口的显式类或匿名内部类的形式，如创建一个新的线程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><br>在java 8中引入了著名的Lambda表达式，对于函数式接口，可以通过Lambda表达式迅速创建，减少了语法冗余。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相当于创建了一个Runnable接口实例，并传入</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;System.out.println(<span class="string">&quot;Hello World&quot;</span>);&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//这样也是可以的</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> ()-&gt;&#123;System.out.println(<span class="string">&quot;Hello World&quot;</span>);&#125;;</span><br></pre></td></tr></table></figure><br><span id="more"></span></p>
<h4 id="2-2-函数式接口的自定义"><a href="#2-2-函数式接口的自定义" class="headerlink" title="2.2 函数式接口的自定义"></a>2.2 函数式接口的自定义</h4><p>函数式接口有且仅有一个抽象方法。值得注意的是，在java 8之前，java接口所有方法都是抽象的，无论是否显式用abstract关键字修饰。在java 8中给接口引入了默认方法（Default Method），用default关键字修饰，类似于默认参数的概念，这个方法自然是有实现体的非抽象方法。另外值得注意的是，虽然函数式接口一般都会用<code>@FunctionalInterface</code>标注，但这个标注不是必须的，这这是方便编译器检查，当进行标注而不是函数式接口时，编译器会报错。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span>  <span class="comment">//这个标注不是必须的，符合函数式接口定义即可</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyFunctionInterface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">print1</span><span class="params">()</span>&#123;&#125; <span class="comment">//函数式接口允许多个非抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">print2</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>此外<strong>这里的抽象方法不包括从Object类继承的抽象方法</strong>，如<code>java.util.Comparator&lt;T&gt;</code>就重写了继承自<code>Object</code>的<code>equals</code>方法。我认为作者之所以显式重写抽象方法，实际上只是想说明比较器之前也能比较，但实际意义不大，因为它还是抽象的，利用了<code>Object</code>的default方法，比较两者地址是否一致。不过在编写代码时是不能将接口显式声明<code>extends Object</code>的，因为类和接口是两个体系，即接口只能继承接口。只是Object作为一个特殊，jvm会将Object类的方法自动继承给接口，个人理解是为了方便创建匿名内部类而无需用具名类<code>implements</code>这个接口，因为接口最终都是利用类实现的，不论什么类继承自Object类，正如<code>&lt;&lt;Java语言规范&gt;&gt;</code>所说：</p>
<p><code>If an interface has no direct superinterfaces, then the interface implicitly declares a public abstract member method m with signature s, return type r, and throws clause t corresponding to each public instance method m with signature s, return type r, and throws clause t declared in Object, unless a method with the same signature, same return type, and a compatible throws clause is explicitly declared by the interface. It is a compile-time error if the interface explicitly declares such a method m in the case where m is declared to be final in Object.</code></p>
<h4 id="2-3-Lambda表达式"><a href="#2-3-Lambda表达式" class="headerlink" title="2.3 Lambda表达式"></a>2.3 Lambda表达式</h4><p>java的Lambda表达式语法与JavaScript、C++的Lambda表达式语法相近。其参数用“()”显示标出，函数体用“{}”显示标出，中间用“-&gt;”分隔。当单参数或单语句时，对应括号可隐藏。Lambda表达式的参数与返回值类型必须与对应的函数式接口的抽象方法类型一致。</p>
<p>实际上，Python、JavaScript、C++都能显式的传递函数指针，定义函数指针变量，动态决定函数体，因此lambda的意义个人觉得反而不如Java。此外Perl在Perl6中也引入了Lambda而支持函数式编程（函数式编程相对的是指令式编程，函数式编程关注的是映射关系，纯粹的函数式编程是没有变量的，只要输入确定输出就确定，这也是闭包或lambda表达式中外部局部变量不能改变的原因）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java Lambda</span></span><br><span class="line">(<span class="type">int</span> x, <span class="type">int</span> y)-&gt;&#123;<span class="keyword">return</span> x+y;&#125;;                           <span class="comment">//显式声明参数类型，是个好习惯，方便阅读</span></span><br><span class="line">(x, y)-&gt;&#123;<span class="keyword">return</span> x+y;&#125;;                                   <span class="comment">//不声明参数类型，根据对应函数式接口判断</span></span><br><span class="line">x-&gt;&#123;<span class="keyword">return</span> x+<span class="number">1</span>;&#125;;                                        <span class="comment">//单参数时，不用圆括号</span></span><br><span class="line">x-&gt;x+<span class="number">1</span>;                                                  <span class="comment">//单语句时，不用花括号，此时默认返回值即语句返回值，不能使用return语句</span></span><br><span class="line">()-&gt;<span class="string">&quot;Hello World&quot;</span>;                                       <span class="comment">//无参数</span></span><br><span class="line">()-&gt;System.out.println(<span class="string">&quot;Hello world&quot;</span>);                   <span class="comment">//无返回值</span></span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++ Lambda，实际上创建的是函数的栈指针，可用auto进行类型推断，也可显式声明函数指针</span></span><br><span class="line"><span class="keyword">auto</span> functionptr0 = [local_val](<span class="type">int</span> x)&#123;<span class="keyword">return</span> x + <span class="number">1</span>;&#125;;    <span class="comment">//[]声明使用的外部局部变量，()显式声明函数参数，&#123;&#125;为函数体</span></span><br><span class="line"><span class="built_in">int</span> (*functionptr1)() = []()-&gt;<span class="type">int</span>&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;              <span class="comment">//可以用“-&gt;”指定返回类型，这与java对该符号的使用不同.</span></span><br><span class="line"><span class="built_in">functionptr0</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JavaScript Lambda</span></span><br><span class="line"><span class="keyword">const</span> function0 = <span class="keyword">function</span>(<span class="params"></span>)&#123;....&#125;;                        <span class="comment">//在ES6之前，一般使用匿名函数来实现函数回调、闭包等。</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">function1</span> = (<span class="params">a, b</span>)=&gt;&#123;a+b;&#125;;                          <span class="comment">//ES6引入“=&gt;”Lambda表达式，形式与java几乎一致</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">function2</span> = a=&gt;a+b;                                  <span class="comment">//单语句时，不用花括号，此时默认返回值即语句返回值，不能使用return语句</span></span><br></pre></td></tr></table></figure><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##Python Lambda</span></span><br><span class="line">function0 = <span class="keyword">lambda</span> a,b,c:a+b+c                              <span class="comment">##Python使用lambda关键字声明，参数与函数体用:分隔，语句结果即为返回值</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">值得注意的是，相比前面几位，Python的Lambda表达式更像是表达式，其函数体只能支持使用表达式而不能使用赋值语句</span></span><br><span class="line"><span class="string">不能使用()、&#123;&#125;进行参数与函数体界定，因为python本身作用域是依靠缩进判断的。故Python的lambda适用于简单使用。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">function1 = <span class="keyword">lambda</span> a,b,c:&#123;a+b+c&#125; <span class="comment">##这是合法的，但返回值是单个元素的集合，&#123;&#125;是集合定界符</span></span><br></pre></td></tr></table></figure></p>
<h4 id="2-4-Java-经典函数式接口"><a href="#2-4-Java-经典函数式接口" class="headerlink" title="2.4 Java  经典函数式接口"></a>2.4 Java  经典函数式接口</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">接口全限定名</th>
<th style="text-align:left">抽象方法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>java.until.function.Consumer&lt;T&gt;</code></td>
<td style="text-align:left">void accept(T t)</td>
<td style="text-align:left">消费型接口，一个参数，无返回值,since 1.8</td>
</tr>
<tr>
<td style="text-align:left"><code>java.until.function.Supplier&lt;T&gt;</code></td>
<td style="text-align:left">T get()</td>
<td style="text-align:left">供给型接口, 没有参赛，有返回值,since 1.8</td>
</tr>
<tr>
<td style="text-align:left"><code>java.until.function.Function&lt;T, R&gt;</code></td>
<td style="text-align:left">R apply(T t)</td>
<td style="text-align:left">函数型接口, 一个参数，有返回值,since 1.8</td>
</tr>
<tr>
<td style="text-align:left"><code>java.until.function.Predicate&lt;T&gt;</code></td>
<td style="text-align:left">boolean test(T t)</td>
<td style="text-align:left">断言型接口，一个参数，有返回值,since 1.8, 返回boolean值为判断结果</td>
</tr>
<tr>
<td style="text-align:left"><code>java.lang.Runnable</code></td>
<td style="text-align:left">public abstract void run</td>
<td style="text-align:left">可运行接口，没有参数，无返回值,since 1.0, 为多线程使用</td>
</tr>
<tr>
<td style="text-align:left"><code>java.util.Comparator&lt;T&gt;</code></td>
<td style="text-align:left">public int compare(T o1, T o2)</td>
<td style="text-align:left">比较型接口，一个参数，有返回值,since 1.2</td>
</tr>
</tbody>
</table>
</div>
<p>此外，在java 8在java.until.function包内提供了许多其他函数式接口。详细可参考<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/">javadoc 8</a>。</p>
<h4 id="2-5-Java标准库中的应用身影"><a href="#2-5-Java标准库中的应用身影" class="headerlink" title="2.5 Java标准库中的应用身影"></a>2.5 Java标准库中的应用身影</h4><p><code>java.lang.Iterable&lt;T&gt;</code>的<code>public default void forEach(Consumer&lt;? super T&gt; action)</code></p>
<p><code>java.util.List&lt;E&gt;</code>的<code>public default void sort(Comparator&lt;? super E&gt; c)</code></p>
<h4 id="2-6-Lambda表达式的特殊形式"><a href="#2-6-Lambda表达式的特殊形式" class="headerlink" title="2.6 Lambda表达式的特殊形式"></a>2.6 Lambda表达式的特殊形式</h4><p>对于只是传递已经的方法，可以使用“::”快速构建函数式接口实例，简化代码表达（类似于python将函数名作为变量传入）。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> System.out::println;</span><br><span class="line"><span class="comment">//等效于</span></span><br><span class="line"><span class="type">Runable</span> <span class="variable">r</span> <span class="operator">=</span> ()-&gt;System.out.println();</span><br><span class="line"></span><br><span class="line">Consumer&lt;String&gt; consumer = System.out::println;</span><br><span class="line"><span class="comment">//等效于</span></span><br><span class="line">Consumer&lt;String&gt; consumer = (String s)-&gt;System.out.println(s);</span><br></pre></td></tr></table></figure><br>上述要求函数的参数、返回值与函数式接口方法一致。 上面两个println是两个重载方法。</p>
<h3 id="三、Java线程基础"><a href="#三、Java线程基础" class="headerlink" title="三、Java线程基础"></a>三、Java线程基础</h3><h4 id="3-1-synchronized关键字"><a href="#3-1-synchronized关键字" class="headerlink" title="3.1 synchronized关键字"></a>3.1 synchronized关键字</h4><p>synchronized是同步的意思，java中用该关键字让当前线程获取对象的锁。当无法获取对象的锁时（即对象的锁被别的线程占据），当前线程会等待该对象的锁释放再获取。即当前线程被动阻塞。<br>synchronized关键字可以修饰直接修饰特定对象，也可以修饰对象的实例方法或类的静态方法。<strong>实例方法修饰实际上是让当前线程获取方法所属对象的锁，静态方法修饰则是获取所属类的锁，两者不存在冲突</strong>。当前所有请求获得该对象锁的线程均在该对象对应的<strong>同步队列</strong>中。</p>
<h4 id="3-2-wait方法"><a href="#3-2-wait方法" class="headerlink" title="3.2 wait方法"></a>3.2 wait方法</h4><p>wait方法是定义在<code>java.lang.Object</code>中方法，重载方法<code>wait(long millis)</code>为native方法。当前线程获得该对象的锁时，可以调用这个方法使得当前线程进入该对象的线程等待队列并阻塞。<code>wait()</code>实际调用native方法<code>wait(0)</code>，表示一直阻塞，直到接收当该对象的恢复通知并从其线程等待队列中放出。而当native方法的<code>millis &gt; 0</code>时，代表只是阻塞一段时间。</p>
<h4 id="3-3-notify方法"><a href="#3-3-notify方法" class="headerlink" title="3.3 notify方法"></a>3.3 notify方法</h4><p>notify是定义在<code>java.lang.Object</code>中方法，当前线程获得该对象的锁时，可以调用这个方法使得<strong>该对象的线程等待队列中第一个等待线程</strong>被取出而取消被动阻塞。取出的线程由于进入时是在synchronized关键字代码段中，即那时候（被wait的时候）拥有当前对象的锁，因此<strong>它会加入当前对象的同步队列</strong>，按照优先级重新等待获取当前对象的锁，此时若还没获取当前对象的锁，线程会主动阻塞自己等待获取对象的锁。</p>
<h4 id="3-4-notifyAll方法"><a href="#3-4-notifyAll方法" class="headerlink" title="3.4 notifyAll方法"></a>3.4 notifyAll方法</h4><p>notifyAll是定义在<code>java.lang.Object</code>中方法，当前线程获得该对象的锁时，可以调用这个方法使得<strong>该对象的线程等待队列被清空</strong>，所有在其中的线程会被释放，并同理会进入该对象的同步队列，按照优先级重新获取当前对象的锁。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 下面代码三个子线程依次输出1、2、3。若主线程使用notifyAll()，那么子线程之间将会进行竞争，由于优先级一致，会有不同的顺序可能。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; </span><br><span class="line">        <span class="keyword">synchronized</span>(flag) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                flag.wait(); <span class="comment">//子线程1获得flag的锁，被放入等待队列，然后临时释放拥有的锁</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(flag) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                flag.wait();<span class="comment">//子线程2获得flag的锁，被放入等待队列，然后临时释放拥有的锁</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(flag) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                flag.wait();<span class="comment">//子线程3获得flag的锁，被放入等待队列，然后临时释放拥有的锁</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">synchronized</span>(flag) &#123;<span class="comment">//主线程获得对象flag的锁</span></span><br><span class="line">        flag.notify();<span class="comment">//子线程1被放出，进入flag的同步队列，此时flag的锁在主线程手中</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">while</span> (System.currentTimeMillis() - start &lt; <span class="number">1000</span>);</span><br><span class="line">    &#125;<span class="comment">//主线程释放对象flag的锁</span></span><br><span class="line">    Thread.sleep(<span class="number">5000</span>);<span class="comment">//主线程休眠，让优先级较低的子线程1获取flag的锁</span></span><br><span class="line">    <span class="keyword">synchronized</span>(flag) &#123;<span class="comment">//主线程获得对象flag的锁</span></span><br><span class="line">        flag.notify();<span class="comment">//子线程2被放出，进入flag的同步队列，此时flag的锁在主线程手中</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">while</span> (System.currentTimeMillis() - start &lt; <span class="number">1000</span>);</span><br><span class="line">    &#125;<span class="comment">//主线程释放对象flag的锁</span></span><br><span class="line">    Thread.sleep(<span class="number">5000</span>);/主线程休眠，让优先级较低的子线程<span class="number">2</span>获取flag的锁</span><br><span class="line">    <span class="keyword">synchronized</span>(flag) &#123;</span><br><span class="line">        flag.notify();</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">while</span> (System.currentTimeMillis() - start &lt; <span class="number">1000</span>);</span><br><span class="line">    &#125;<span class="comment">//主线程释放对象flag的锁，子线程3获取flag的锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-5-sleep方法"><a href="#3-5-sleep方法" class="headerlink" title="3.5 sleep方法"></a>3.5 sleep方法</h4><p><code>sleep</code>方法定义于<code>java.lang.Thread</code>中，属于native的静态方法，可以让当前线程休眠指定时间。但与wait不同的是，sleep方法并不释放对象的锁，也不要求获得谁的锁才能调用。因此sleep方法不影响锁的争取顺序。其实质是等同上面代码中的while循环拖延时间。</p>
<h4 id="3-6-yield方法"><a href="#3-6-yield方法" class="headerlink" title="3.6 yield方法"></a>3.6 yield方法</h4><p>yield方法定义于<code>java.lang.Thread</code>中，是native的静态方法，其作用在于告诉JVM当前线程愿意放弃资源，从<strong>正在运行状态转为可运行状态</strong>，将运行资源转给线程池中的相同优先级线程。但值得注意的是，你告诉JVM你现在不忙，不代表JVM真会理你，只是让JVM指定一下罢了，<strong>不一定起效，具体看JVM的衡量</strong>。</p>
<h4 id="3-7-join方法"><a href="#3-7-join方法" class="headerlink" title="3.7 join方法"></a>3.7 join方法</h4><p>join方法定义于<code>java.lang.Thread</code>中，当主线程调用子线程实例的join方法，会使得主线程被阻塞直至子线程完成或阻塞一段指定的时间。join这一个名字很好的表达了这个方法，<strong>它可以让子线程结果插入到主线程的指定位置，从而可以在利用多线程完成任务的同时获得任务结果</strong>。</p>
<p>join方法就很好地使用了同步对象与同步方法。早些版本的<strong>join方法的源码</strong>（如下）采用的是synchronized修饰一个直观的对象，现行采用了<strong>修饰方法</strong>。因为当前线程调用子线程实例的join方法阻塞当前线程和子线程完成后notifyAll通知当前线程继续时，使用子线程实例作为加锁对象是最为合适的。因此采用synchronized方法更加简便不易出问题。</p>
<p>通过源码阅读，我们可以清楚知道，其实join方法就是基于wait和notify/notifyAll方法来实现。因此很多多线程任务不直接使用wait/notify，而是使用了join方法。（<strong>javadoc中原文： It is recommended that applications not use wait, notify, or notifyAll on Thread instances.</strong>）join方法的时间参数与wait方法是一样的作用。</p>
<p>源码中调用了wait是看到的，那么notify在哪，谁notify的，这其实是由jvm在结束子线程是自动完成的，参加<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4322fbe767c4">大佬文章</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="keyword">final</span> <span class="type">long</span> millis)</span></span><br><span class="line"><span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (millis &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isAlive()) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> millis;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                wait(delay);</span><br><span class="line">            &#125; <span class="keyword">while</span> (isAlive() &amp;&amp; (delay = millis -</span><br><span class="line">                    TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime)) &gt; <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="java-util-concurrent-locks-Lock接口"><a href="#java-util-concurrent-locks-Lock接口" class="headerlink" title="java.util.concurrent.locks.Lock接口"></a>java.util.concurrent.locks.Lock接口</h4><p>Lock接口是java实现的api，同样可以实现synchronized关键字的作用，参见<a target="_blank" rel="noopener" href="https://www.cnblogs.com/qifengshi/p/6354890.html">文档</a> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">lock.lock();<span class="comment">//取锁</span></span><br><span class="line">.....<span class="comment">//相当于synchronized的代码块中同步内容，此时的锁的对象正是lock实例，当某个线程获得锁时，其他线程也就卡在了lock.lock()这里。</span></span><br><span class="line">lock.unlock();<span class="comment">//放锁</span></span><br></pre></td></tr></table></figure>
<h3 id="四、Java泛型（generics）浅涉"><a href="#四、Java泛型（generics）浅涉" class="headerlink" title="四、Java泛型（generics）浅涉"></a>四、Java泛型（generics）浅涉</h3><p>Java泛型自Java 1.5引入，其泛型实现由编译器支持，并没有重构JVM。泛型类在字节码（.class）中与普通类无异。如<code>List&lt;String&gt;</code>和<code>List&lt;Integer&gt;</code>在字节码中是一个类，都是原生类型<code>List</code>。这与C++的模板泛型有很大不同。在C++中，编译器利用模板类<code>Vector&lt;T&gt;</code>可以生成<code>Vector&lt;int&gt;</code>、<code>Vector&lt;string&gt;</code>和<code>Vector&lt;bool&gt;</code>等不同的具体类型，它们是不同的类。C++模板类造成了模板类相同代码的重复，这是一直被诟病的地方。Java泛型基于<strong>编译器的类型擦除</strong>解决了这个问题，并借此实现够兼容java 1.5之前的普通类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; l1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">List&lt;Integer&gt; l2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">System.out.println(l1.getClass() == l2.getClass());<span class="comment">//结果是true，因为在字节码中只有List原生类型</span></span><br></pre></td></tr></table></figure></p>
<h4 id="4-1-泛型声明"><a href="#4-1-泛型声明" class="headerlink" title="4.1 泛型声明"></a>4.1 泛型声明</h4><p>Java中泛型可分为泛型类、泛型方法和泛型接口，与C++一样，使用“&lt;&gt;”来声明泛型参数。此外能够在参数中应用<strong>extends</strong>关键字来约束泛型的<strong>声明范围</strong>，采用<strong>通配符?</strong>配合<strong>super</strong>和<strong>extends</strong>关键字来约束泛型的<strong>实现范围</strong>。与C++不同的是，java泛型参数指定必须是类/接口，而不能是基本类型int/float/char/double/boolean。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛型类，这是java.util.ArrayList&lt;E&gt;的源码声明，泛型声明&lt;E&gt;紧靠类名</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line"></span><br><span class="line"><span class="comment">//泛型方法，泛型类型由泛型参数推断，因此必须有泛型参数，否则这个泛型没有意义</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">get</span><span class="params">(T t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//泛型接口，这是java.util.List&lt;E&gt;的源码声明，格式与泛型类一致</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;E&gt; </span><br><span class="line"></span><br><span class="line"><span class="comment">//泛型方法可以在泛型类中同时存在，若泛型参数相同，泛型方法使用自身的泛型参数而隐藏类泛型参数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">java</span>.util.ArrayList&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(E r)</span> &#123;</span><br><span class="line">        System.out.println(r.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Vector&lt;String&gt; vector = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">        vector.print(<span class="number">1</span>);<span class="comment">//输出是java.lang.Integer而不是java.lang.String</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//泛型声明还可以通过extends关键字约束泛型声明的上限，其实默认上限就是Object，同类的继承一样。</span></span><br><span class="line"><span class="comment">//extends声明的上限也决定了类型擦除后的具体类型，详见下文</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Integer</span>&gt; <span class="keyword">extends</span> <span class="title class_">java</span>.util.ArrayList&lt;E&gt;</span><br></pre></td></tr></table></figure><br>值得注意的是，<strong>泛型类中静态普通方法不能使用泛型参数</strong>，因为泛型的实现是基于对象而不是类。但是泛型方法可以是静态方法。需要深刻理解泛型方法与普通方法的差异。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">java</span>.util.ArrayList&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(E r)</span> &#123;<span class="comment">//静态泛型方法，通过编译</span></span><br><span class="line">        System.out.println(r.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print2</span><span class="params">(E r)</span> &#123;<span class="comment">//静态普通方法，使用类泛型参数无法通过编译</span></span><br><span class="line">        System.out.println(r.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="4-2-泛型通配符"><a href="#4-2-泛型通配符" class="headerlink" title="4.2 泛型通配符"></a>4.2 泛型通配符</h4><p>一般来说，泛型对象会指定具体的泛型类型，比如<code>ArrayList&lt;Number&gt;</code>和<code>ArrayList&lt;Integer&gt;</code>，在编译阶段，编译器把他俩看做两个不同的类型，无法相互传递引用（反射机制除外）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Number&gt; array1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">ArrayList&lt;Integer&gt; array2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">array1 = array2;<span class="comment">//无法通过编译，会报错。纵然Number是Integer的超类。</span></span><br></pre></td></tr></table></figure><br>但有时候，我们不知道传过来的到底是啥泛型类型，我们也不care是啥泛型类型因为我们不需要去操作泛型实例只需要看一下这个对象的一些与泛型类型无关的属性如ArrayList的元素个数等，这时候通配符?就派上用处了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;?&gt; array3= array2;<span class="comment">//编译通过，代价时无法进行与泛型相关的操作，如array3.add()方法需要传入泛型实例，只能用array3.size()这种。 </span></span><br><span class="line">array3.add(<span class="number">1</span>);<span class="comment">//编译不通过，当然通过反射机制能够绕开这个限制</span></span><br><span class="line">array3.size();<span class="comment">//编译通过</span></span><br><span class="line"><span class="comment">//编译通过，利用反射机制绕过限制，原因在于类型擦除，但一般没谁闲得慌干这个骚操作，这个操作同时跳脱了array2本身的泛型类型限制</span></span><br><span class="line">array3.getClass().getMethod(<span class="string">&quot;add&quot;</span>, Object.class).invoke(array3, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//extends决定通配符的上限（包括），此案例不通过编译</span></span><br><span class="line">ArrayList&lt;? <span class="keyword">extends</span> <span class="title class_">Integer</span>&gt; array4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//super决定通配符的下限（包括），此案例不通过编译</span></span><br><span class="line">ArrayList&lt;? <span class="built_in">super</span> Number&gt; array4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br></pre></td></tr></table></figure></p>
<h4 id="4-3-类型擦除"><a href="#4-3-类型擦除" class="headerlink" title="4.3 类型擦除"></a>4.3 类型擦除</h4><p>前面说过，java泛型只是有编译器所实现，而在字节码文件和JVM中并无区别对待。因为在java编译器中存在一步泛型的类型擦除。类型擦除其实质就是java编译器给我们进行了一次替换，而替换后的类型就右我们显式extends声明或默认extends决定。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛型源码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Generics</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">print</span><span class="params">(E r)</span> &#123;</span><br><span class="line">        System.out.println(r.getClass().getName());</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Generics&lt;Integer&gt; v = <span class="keyword">new</span> <span class="title class_">Generics</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> v.print(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//擦除后的等效源码，当没有声明extends Number，默认是extends Object，因此会替换为Object</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Generics</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Number <span class="title function_">print</span><span class="params">(Number r)</span> &#123;</span><br><span class="line">        System.out.println(r.getClass().getName());<span class="comment">//输出java.lang.Integer</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Generics</span> <span class="variable">v</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Generics</span>();</span><br><span class="line">        <span class="comment">//根据&lt;Integer&gt;指定，施行强制转换，类型安全就由泛型而得到保障，泛型带来最直接的优势也就是不用我们自己去转换</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> (Integer) v.print(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当将上述两段代码分别编译，泛型代码编译后字节码共1205字节，普通代码编译后字节码共958字节，这说明java编译器除了我们说的这个基本过程，还有一些细节信息放在泛型里。但这不影响理解泛型。泛型的类型擦除，所用的具体对象有extends决定，这由反射机制可以很好的验证。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Generics</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; &#123;</span><br><span class="line">    <span class="type">E</span> <span class="variable">infoE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Generics&lt;Integer&gt; v = <span class="keyword">new</span> <span class="title class_">Generics</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(v.getClass().getDeclaredField(<span class="string">&quot;infoE&quot;</span>).getType().getName());<span class="comment">//输出为java.lang.Number</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | SecurityException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可能会疑问为啥前面<code>System.out.println(r.getClass().getName());</code>输出的不是java.lang.Number，不是类型擦除了嘛。那是因为类的多态性决定的。对应<code>Number r = new Integer(10)</code>，这时候r.getClass()方法调用的是Integer子类的方法而非父类Number，返回的Class对象自然是Integer对应的Class对象。而<code>getDeclaredField(&quot;infoE&quot;)</code>返回的是类成员infoE的声明类型对应的Class对象，不存在多态的问题，自然就正如所料。<strong>当然getClass方法是由jvm自动实现的（在Object类中该方法有@HotSpotIntrinsicCandidate标注），不需要自己手动重写，就同自动生成对应Class对象一样</strong>。</p>
<h4 id="4-4-注意事项"><a href="#4-4-注意事项" class="headerlink" title="4.4 注意事项"></a>4.4 注意事项</h4><p>泛型类型<code>T</code>并不是实体类型，因此不能对其进行<code>new T()</code>实例化（编译报错：Cannot instantiate the type T），也不能调用实例类型属性如<code>T.class</code>（编译报错：Illegal class literal for the type parameter T）。故泛型类型只能通过赋值传递，如<code>T c = value</code>，或者调用泛型实例的实例方法如<code>c.getClass().getName()</code>。其实前者很好理解为什么不可，因为泛型类型没有明确的构造器，无法传参。后者理论上其实应该是可以像泛型实例方法一样使用的，但目前编译器不支持。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Data</span><span class="params">(T value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="comment">// 编译正常</span></span><br><span class="line">        <span class="type">T</span> <span class="variable">c</span> <span class="operator">=</span> value;</span><br><span class="line">        <span class="comment">// 编译报错：Cannot instantiate the type T</span></span><br><span class="line">        <span class="type">T</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">        <span class="comment">// 编译正常，利用反射机制掉取构造器创建新类，前提是对该类型构造器清楚</span></span><br><span class="line">        <span class="type">T</span> <span class="variable">f</span> <span class="operator">=</span> (T) value.getClass().getConstructor(String.class).newInstance(<span class="string">&quot;2000&quot;</span>);</span><br><span class="line">        <span class="comment">// 编译正常</span></span><br><span class="line">        System.out.println(value.getClass().getName())；</span><br><span class="line">        <span class="comment">// 编译报错：Illegal class literal for the type parameter T</span></span><br><span class="line">        System.out.printlnt(T.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="五、Java序列化与反序列化技术"><a href="#五、Java序列化与反序列化技术" class="headerlink" title="五、Java序列化与反序列化技术"></a>五、Java序列化与反序列化技术</h3><p>序列化指的是将对象从内存持久化保存到硬盘中，或者用于网络数据传输的一项技术，除了Java，许多语言如Python都支持这项技术。而反序列化顾名思义也就是序列化的逆过程，IO总是有写有读嘛。</p>
<h4 id="5-1-序列化与反序列化的过程"><a href="#5-1-序列化与反序列化的过程" class="headerlink" title="5.1 序列化与反序列化的过程"></a>5.1 序列化与反序列化的过程</h4><p>一个对象想要能够序列化，必须保证自身及其实例成员全部实现<code>java.io.Serilizable</code>接口，这个接口没有什么抽象方法，唯一作用在于告诉JVM这个对象可以序列化。</p>
<p>java使用<code>java.io.ObjectOutputStream</code>实例对象（oos对象）的<code>writeObject</code>方法序列化指定对象到文件。当对象的类自身实现了<code>private void writeObject(java.io.ObjectOutputStream out) throws IOException</code>方法，oos对象会通过<strong>反射机制</strong>调用该方法实现特殊的序列化需求，否则按照java默认方式序列化。<code>java.until.ArrayList&lt;E&gt;</code>实际上就是如此。因为其核心成员elementData是用<strong>transient关键字</strong>修饰的对象数组，该关键字修饰的实例成员在java默认序列化时会被跳过。之所以这样设计是因为数组是整个序列化的，而这个数组其实是预留的最大容量罢了，我们的元素可能只有几个。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是java.until.ArrayList&lt;E&gt;的writeObject源码，通过自定义writeObject，实现只序列化我们的元素，而不序列化整个elementData数组。</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line">....</span><br><span class="line"><span class="meta">@java</span>.io.Serial</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span><br><span class="line">    <span class="keyword">throws</span> java.io.IOException &#123;</span><br><span class="line">    <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out size as capacity for behavioral compatibility with clone()</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>对应的，java使用<code>java.io.ObjectInputStream</code>实例对象（ois对象）的<code>readObject</code>方法反序列化获得对象。当对象的类自身实现了<code>private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException</code>方法，ois对象同样通过反射机制调用该方法实现特殊的反序列化需求，否则按java默认方式反序列化。如前面一样，<code>java.until.ArrayList&lt;E&gt;</code>同样也得自定义readObject方法，以正确读取自定义writeObject方法的序列化数据。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对应的`java.until.ArrayList&lt;E&gt;` readObject方法，与writeObject逻辑对应。</span></span><br><span class="line"><span class="meta">@java</span>.io.Serial</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in capacity</span></span><br><span class="line">    s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// like clone(), allocate array based upon size not capacity</span></span><br><span class="line">        SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Object[].class, size);</span><br><span class="line">        Object[] elements = <span class="keyword">new</span> <span class="title class_">Object</span>[size];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            elements[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        elementData = elements;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.io.InvalidObjectException(<span class="string">&quot;Invalid size: &quot;</span> + size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>此外，值得一提的是，所有可序列化的类，最好都显式指定<code>private static final long serialVersionUID</code>，这是一个类的版本号，java进行反序列化时会将序列化文件中的这个ID与内存中的类进行比对，若不一致会抛出异常。就算你不指定，java也会给个默认ID为1L，因此最好显式指定方便检查。</p>
<h3 id="六、java注解"><a href="#六、java注解" class="headerlink" title="六、java注解"></a>六、java注解</h3><ul>
<li>标注是一种特殊的java类型，与双斜杠等在源码中的注释不同，根据@Rention元标注修饰，可以将标注保留到class文件中</li>
<li>在JVM运行程序时，可以通过反射机制读取记录在class文件中的标注信息，也可以选择在编译时保留用于编译检查</li>
<li>因此，java本身可以利用内置标注类型如@Override等在编译、运行时进行检查，如@Override，这些注解在编译后会删除。</li>
<li>也可以用@Decorated等对类别进行信息提示，这也是eclipse等获取对象信息实现自动补全（当然基于STL模板的自动补全是另外）的基础</li>
<li>在Web应用如Tomcat等，可以利用标注直观的反射读取并设置配置参数，例如@WebServlet、@WebListener</li>
<li>注解的定义使用了<code>@interface</code>关键字，与接口很像，别混了。通过<strong>default</strong>关键字声明默认值（default这货到处充当默认，如接口的默认方法、switch的默认操作）。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123; TYPE, FIELD, METHOD &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> myAna &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;zhang&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="七、java反射"><a href="#七、java反射" class="headerlink" title="七、java反射"></a>七、java反射</h3></li>
<li>java的反射机制本质上是因为所有数据结构都保存在了class文件中而可获取，无论源码修饰符是private、protected</li>
<li>还是public。这些修饰符的作用在在编译检查时进行限制访问，对不符合限制的代码不予以编译通过。</li>
<li>jvm在从class文件中加载一个类时，会自动生成一个java.lang.Class对象，该对象包含了这个class文件的所有数据结构</li>
<li>信息，包括所有变量、常量、构造器、静态方法、实例方法等，无论是否为private修饰。</li>
<li>通过getDeclaredMethod方法可以获得声明的所有方法，产生一个Method对象，调用其invoke方法可以执行对应的方法</li>
<li>通过getDeclaredField方法可以获得声明的所有变量、常量，产生一个Field对象，调用其get方法取值，set方法修改值</li>
<li>常量修改时不会修改类中常量，可以理解为镜像修改</li>
<li>通过getDeclaredAnnotaion方法可以获得标注的所有标注，产生对应的标注对象（如@WebServlet）,并调用各自标注对象</li>
<li>的定义信息方法获取方法值。从而实现各类配置操作</li>
<li>对于权限不足的调用，为抛出IllegalArgumentException，需要先setAccessible(true);</li>
<li>对于调用方法不存在（方法名或参数类型不对），会抛出NoSuchMethodException</li>
<li>对于调用方法invoke时，对应参数不对，会抛出IllegalArgumentException</li>
<li>对应调用变量常量不存在（名称不对），会抛出NoSuchFieldException</li>
<li>java的封装性作为其一大特征，其实指的是对外部用户使用是进行了默认的调用限制，从而避免了用户错误调用内部方法</li>
<li>而产生不必要的问题，确保用户使用统一外部接口，但这并不是拒绝了其他用户访问内部方法，通过反射机制可以再必要时</li>
<li>实现内部访问。这与封装的目的不相互冲突。毕竟恶意调用内部方法只能给使用者自己造成Bug。</li>
<li>当然反射机制为class的反编译提供了帮助，这在知识产权保护上有所不利</li>
</ul>
<h3 id="八、java内置数组"><a href="#八、java内置数组" class="headerlink" title="八、java内置数组"></a>八、java内置数组</h3><p><strong>Java中数组是直接继承Object类的对象</strong>。但与普通类不同的是，数组是<strong>由JVM直接创建的</strong>，没有外部定义的class文件。其实我觉得可以理解为JVM内置了数组这样一个泛型类，因此不用外部定义类，JVM当在字节码文件中看到需要创建数组，不会去标准库中寻找定义而是直接创建。</p>
<h3 id="九、java基本数据类型的封装"><a href="#九、java基本数据类型的封装" class="headerlink" title="九、java基本数据类型的封装"></a>九、java基本数据类型的封装</h3><p>为了效率，java对基础的几种数据类型并没有使用对象类型，而是和C++一样使用了简单类型，他们是byte、char、int、long、float、double和bool。在<code>java.lang</code>包中提供了对应的封装类。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">基本类型</th>
<th style="text-align:left">封装类</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">byte</td>
<td style="text-align:left">Byte</td>
<td style="text-align:left">字节型</td>
</tr>
<tr>
<td style="text-align:left">char</td>
<td style="text-align:left">Character</td>
<td style="text-align:left">字符类型</td>
</tr>
<tr>
<td style="text-align:left">int</td>
<td style="text-align:left">Integer</td>
<td style="text-align:left">整型</td>
</tr>
<tr>
<td style="text-align:left">long</td>
<td style="text-align:left">Long</td>
<td style="text-align:left">长整型</td>
</tr>
<tr>
<td style="text-align:left">float</td>
<td style="text-align:left">Float</td>
<td style="text-align:left">单精度浮点型</td>
</tr>
<tr>
<td style="text-align:left">double</td>
<td style="text-align:left">Double</td>
<td style="text-align:left">双精度浮点型</td>
</tr>
<tr>
<td style="text-align:left">boolean</td>
<td style="text-align:left">Boolean</td>
<td style="text-align:left">布尔型</td>
</tr>
<tr>
<td style="text-align:left">void</td>
<td style="text-align:left">Void</td>
<td style="text-align:left">特殊类型，空</td>
</tr>
</tbody>
</table>
</div>
<p>封装类提供了对应数据类型的一系列工具，此外在Java泛型等需要使用对象的场合能够代替基本类型。JVM自身重载了运算符=，同String类型一样，可以方便的转换基本类型和引用类型。</p>
<p>void关键字不是数据类型，它表示的是没有返回值。Void封装类一个作用在于对于一些需要返回值的泛型类型，在实现时不需要返回值时可以指定为Void类型，Void类型只能接受null。通过源码我们可以知道Void类这一特点的实现时<strong>使用了private修饰的空构造方法来代替默认构造方法</strong>，使得Void类型永远只能是引用类型的默认值null而无法初始化。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Void</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * The Void class cannot be instantiated.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Void</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure><br>此外Void封装类可以再反射中用来获取没有返回值（void）的方法。下面代码中输入main和hello两个无返回值方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">arrayParam</span> &#123;</span><br><span class="line">    String <span class="title function_">hello</span><span class="params">()</span> &#123;<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;&#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(Object... args)</span> &#123;</span><br><span class="line">        System.out.println(args.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Method method: arrayParam.class.getDeclaredMethods()) &#123;</span><br><span class="line">            System.out.println(method.getReturnType());</span><br><span class="line">            <span class="keyword">if</span> (method.getReturnType().equals(Void.TYPE)) &#123;</span><br><span class="line">                System.out.println(method.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>值得注意的是，用的<strong>Void.TYPE</strong>属性。封装类的TYPE属性指的是其<strong>对应基本类型的Class对象</strong>，这与封装类对应的Class对象是不同的，即<code>Void.class!=Void.TYPE</code>。通过阅读封装类的源码，我们可以看到这个属性是利用Class类的native static方法<code>getPrimitiveClass(String name)</code> ,Class类javadoc对其描述就是获取原始类型（primitive）的Class对象。这个方法解决了原始类型（基本类型）没有class属性的尴尬，也避免了无法通过Class泛型创建基本类型的Class对象的尴尬（基本类型不能用于泛型）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这是getPrimitiveClass方法的源码</span></span><br><span class="line"><span class="comment">* Return the Virtual Machine&#x27;s Class object for the named</span></span><br><span class="line"><span class="comment">* primitive type.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">native</span> Class&lt;?&gt; getPrimitiveClass(String name);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是所有常见封装类的TYPE属性声明</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;Integer&gt;   TYPE = (Class&lt;Integer&gt;) Class.getPrimitiveClass(<span class="string">&quot;int&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;Void&gt;      TYPE = (Class&lt;Void&gt;) Class.getPrimitiveClass(<span class="string">&quot;void&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;Long&gt;      TYPE = (Class&lt;Long&gt;) Class.getPrimitiveClass(<span class="string">&quot;long&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;Double&gt;    TYPE = (Class&lt;Double&gt;) Class.getPrimitiveClass(<span class="string">&quot;double&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;Float&gt;     TYPE = (Class&lt;Float&gt;) Class.getPrimitiveClass(<span class="string">&quot;float&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;Byte&gt;      TYPE = (Class&lt;Byte&gt;) Class.getPrimitiveClass(<span class="string">&quot;byte&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;Character&gt; TYPE = (Class&lt;Character&gt;) Class.getPrimitiveClass(<span class="string">&quot;char&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;Boolean&gt;   TYPE = (Class&lt;Boolean&gt;) Class.getPrimitiveClass(<span class="string">&quot;boolean&quot;</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="十、java-native-interface（JNI）接口"><a href="#十、java-native-interface（JNI）接口" class="headerlink" title="十、java native interface（JNI）接口"></a>十、java native interface（JNI）接口</h3><p>java本地接口可以实现调用非java代码，主要是C/C++代码，从而实现一些java自身不好实现的功能。步骤如下</p>
<p>（1）编写一个包含native方法的java文件，native关键字修饰<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">nativeHelloWorld</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        print(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String args)</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.load(<span class="string">&quot;D:/zhang/userfile/office/Study/IDRB/Java/java_test/libnativeHelloWorld.dll&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>（2）在早期jdk，使用javah命令处理编译后的class文件，生成对应的nativeHelloWorld.h头文件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javah -jni nativeHelloWorld</span><br></pre></td></tr></table></figure><br>在jdk 10以后，javah被整合至javac中，通过-h参数表明为javah操作并指导输出目录。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -h &lt;目标文件夹&gt; nativeHelloWord.java</span><br></pre></td></tr></table></figure><br>（3）修改生成的h头文件，实现native方法对应的C/C++函数声明。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JNIEXPORT <span class="type">void</span> JNICALL <span class="title">Java_nativeHelloWorld_print</span></span></span><br><span class="line"><span class="function"><span class="params">(JNIEnv * env, jclass obj, jstring args)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; env-&gt;<span class="built_in">GetStringUTFChars</span>(args, <span class="literal">NULL</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="十一、class文件"><a href="#十一、class文件" class="headerlink" title="十一、class文件"></a>十一、class文件</h3><p><code>javap -v &lt;CLASS&gt;</code></p>
<p>该命令可以查看class文件内部信息</p>
<h3 id="十二、java与操作系统命令交互"><a href="#十二、java与操作系统命令交互" class="headerlink" title="十二、java与操作系统命令交互"></a>十二、java与操作系统命令交互</h3><h4 id="12-1-Runtime-getRuntime-exec"><a href="#12-1-Runtime-getRuntime-exec" class="headerlink" title="12.1 Runtime.getRuntime().exec"></a>12.1 Runtime.getRuntime().exec</h4><p>java的exec命令提供了一种快捷运行系统命令的方法，运行完毕（此时会阻塞当前线程）会返回一个Process进程对象。通过进程对象可以获取命令的输出等信息。但无法再命令运行期间动态查看输出。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Process</span> <span class="variable">p</span> <span class="operator">=</span> Runtime.getRuntime().exec(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;</span><br><span class="line">    <span class="string">&quot;jupyter-lab&quot;</span>,</span><br><span class="line">    <span class="string">&quot;--allow-root&quot;</span>,</span><br><span class="line">    <span class="string">&quot;--port&quot;</span>, <span class="string">&quot;8080&quot;</span>,</span><br><span class="line">    <span class="string">&quot;--ip&quot;</span>, <span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(p.getInputStream()));</span><br><span class="line"><span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">    System.out.println(line);</span><br><span class="line">&#125;</span><br><span class="line">br.close();</span><br></pre></td></tr></table></figure></p>
<h4 id="12-2-ProcessBuilder"><a href="#12-2-ProcessBuilder" class="headerlink" title="12.2 ProcessBuilder"></a>12.2 ProcessBuilder</h4><p>前面exec是一种快捷执行的方法，但是不适合命令运行期间动态获取输出。ProcessBuilder是更为基础的工具，exec命令实际上是基于ProcessBuilder开发的（下面片段是jdk 15源代码）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Process <span class="title function_">exec</span><span class="params">(String[] cmdarray, String[] envp, File dir)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>(cmdarray)</span><br><span class="line">        .environment(envp)</span><br><span class="line">        .directory(dir)</span><br><span class="line">        .start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>ProcessBuilder可以指定命令、命令的环境变量、运行目录和输入输出设备等。在exec命令中，输出被传入管道送给java而无法立即在终端看到。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ProcessBuilder</span> <span class="variable">pb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;</span><br><span class="line">    <span class="string">&quot;jupyter-lab&quot;</span>,</span><br><span class="line">    <span class="string">&quot;--allow-root&quot;</span>,</span><br><span class="line">    <span class="string">&quot;--port&quot;</span>, <span class="string">&quot;8080&quot;</span>,</span><br><span class="line">    <span class="string">&quot;--ip&quot;</span>, <span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line">pb.redirectOutput(ProcessBuilder.Redirect.INHERIT); <span class="comment">//重定向输出到当前终端</span></span><br><span class="line">pb.redirectError(ProcessBuilder.Redirect.INHERIT);  <span class="comment">//重定向错误到当前终端</span></span><br><span class="line"><span class="type">Process</span> <span class="variable">p</span> <span class="operator">=</span> pb.start();</span><br><span class="line">p.waitFor(); <span class="comment">//阻塞当前线程以观察输出。</span></span><br></pre></td></tr></table></figure></p>
<h3 id="十三、好用的第三方库"><a href="#十三、好用的第三方库" class="headerlink" title="十三、好用的第三方库"></a>十三、好用的第三方库</h3><h4 id="13-1-Lomdok插件"><a href="#13-1-Lomdok插件" class="headerlink" title="13.1 Lomdok插件"></a>13.1 Lomdok插件</h4><p>使用<code>@Data、@Getter、@Setter</code>等注解，减少代码冗余。其原理是通过自定义注解处理器，在编译时修改class文件，使得开发者不用再源码中书写getter/setter等模板代码。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="13-2-fastjson"><a href="#13-2-fastjson" class="headerlink" title="13.2 fastjson"></a>13.2 fastjson</h4><p>由阿里巴巴开发的JSON处理器，能够快速实现JSON字符串反序列化为Java对象或将Java对象序列化为JSON字符串。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.76<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="13-3-jsch"><a href="#13-3-jsch" class="headerlink" title="13.3 jsch"></a>13.3 jsch</h4><p>一款纯java开发的ssh实现，可以方便java程序进行ssh远程通讯。<a target="_blank" rel="noopener" href="http://www.jcraft.com/jsch/">官网</a>有许多示例代码。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.jcraft/jsch --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.jcraft<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.1.55<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="13-4-velocity"><a href="#13-4-velocity" class="headerlink" title="13.4 velocity"></a>13.4 velocity</h4><p>由Apache开源组织开发一块模板引擎，对于Web开发有着很高效的作用。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.velocity/velocity --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.velocity<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>velocity<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="13-5-jedis"><a href="#13-5-jedis" class="headerlink" title="13.5 jedis"></a>13.5 jedis</h4><p>Redis是一款经典的非关系型缓存数据库。不像关系型数据库有着丰富的JDBC接口及扩展。jedis是一款好用的Redis服务处理工具。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="13-6-druid"><a href="#13-6-druid" class="headerlink" title="13.6 druid"></a>13.6 druid</h4><p>druid是由阿里巴巴开发一款业内公认好用的JDBC数据库连接池。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><h4 id="JVM参数"><a href="#JVM参数" class="headerlink" title="JVM参数"></a>JVM参数</h4><h3 id="try-语句资源释放"><a href="#try-语句资源释放" class="headerlink" title="try 语句资源释放"></a>try 语句资源释放</h3><p>对于实现<code>java.lang.AutoCloseable</code>或<code>java.lang.Closeable</code>接口的类，可以通过try语句自动调用close方法释放资源。同时可以配合catch和finally语句执行一些操作。InputStream和OutputStream两个抽象类均实现了Closeable接口，故其子类均可以使用try语句自动关闭资源。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;input.txt&quot;</span>);</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>);</span><br><span class="line">) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; finaly &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?src=11&amp;timestamp=1612656444&amp;ver=2875&amp;signature=XKtcDNGyjgrm1epPcCVHe6vHngXQGrngouDC9ZuURMChveD-b2an8wXrA8wpcdjuwamYI4id2ekFVSlFpT9vn0-ucKkB3fC6HO-CxeJMMFlNT9CAkfht-eN1OR0Ny0pn&amp;new=1">Java 泛型，你了解类型擦除吗？</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/aoguren/p/4767309.html">ArrayList序列化技术细节详解</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jb51.net/article/131118.htm">java.lang.Void类的解析与使用详解</a></li>
<li><a target="_blank" rel="noopener" href="https://ask.csdn.net/questions/151933">CSDN java反射的一些困惑</a></li>
</ul>
</div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-meta">本文作者: </span><span class="post-copyright-info"><a href="mailto:undefined">GCS-ZHN</a></span></div><div class="post-copyright-type"><span class="post-copyright-meta">本文链接: </span><span class="post-copyright-info"><a href="https://gcszhn.top/2022/03/10/java/">https://gcszhn.top/2022/03/10/java/</a></span></div><div class="post-copyright-notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://gcszhn.top">潇洒记忆</a>！</span></div></div></article><div id="pagination"><div class="prev-post pull-left"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/2022/03/10/git/"><i class="fas fa-angle-left">&nbsp;</i><span>Git学习笔记</span></a></div><div class="next-post pull-right"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/2021/05/13/cpp/"><span>C++学习笔记</span><span>&nbsp;</span><i class="fas fa-angle-right"></i></a></div></div><!--div!= paginator()--></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-file-o"></i></span><span id="busuanzi_value_page_pv"></span><span></span></div><div class="copyright">&copy;2017 ～ 2025 By GCS-ZHN</div><a href="https://beian.miit.gov.cn/" target="_blank">&nbsp; 浙ICP备2022014039号</a></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--></body></html>