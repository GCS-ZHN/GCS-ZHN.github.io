<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="python学习笔记"><meta name="keywords" content="python"><meta name="author" content="GCS-ZHN,undefined"><meta name="copyright" content="GCS-ZHN"><title>python学习笔记【潇洒记忆】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><link rel="icon" href="/favicon.ico"><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- script(src=url_for("/js/mathjax/mathjax.js"))--><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  gitment: {},
  valine: {},
}</script><meta name="generator" content="Hexo 6.0.0"></head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="toggle-sidebar-info button-hover"><span data-toggle="文章目录">站点概览</span></div><div class="sidebar-toc"><div class="sidebar-toc-title">目录</div><div class="sidebar-toc-progress"><span class="progress-notice">您已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc-progress-bar"></div></div><div class="sidebar-toc-content" id="sidebar-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.</span> <span class="toc-text">一、类与对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%A0%B9%E7%B1%BB%E5%92%8C%E5%85%83%E7%B1%BB"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 根类和元类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-python%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 python对象的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-python%E7%9A%84%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 python的多继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%90%8C%E6%AD%A5%E8%BF%90%E7%AE%97"><span class="toc-number">2.</span> <span class="toc-text">二、同步运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%8D%95%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 单个线程的创建与使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 线程同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 线程池的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E8%BF%9B%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 进程池的使用</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/avatar.png"></div><div class="author-info-name">GCS-ZHN</div><div class="author-info-description"></div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/GCS-ZHN" target="_blank">GitHub<i class="icon-dot bg-color9"></i></a><a class="links-button button-hover" href="mailto:zhang.h.n@foxmail.com" target="_blank">E-Mail<i class="icon-dot bg-color9"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/archives"><span class="pull-top">日志</span><span class="pull-bottom">24</span></a><a class="author-info-articles-tags article-meta" href="/tags"><span class="pull-top">标签</span><span class="pull-bottom">50</span></a><a class="author-info-articles-categories article-meta" href="/categories"><span class="pull-top">分类</span><span class="pull-bottom">16</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/archives">归档</a></nav><div class="right-info"><a class="title-name" href="/">潇洒记忆</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="title">python学习笔记</div><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 发表于 2022-04-17 | 更新于 2022-11-10</time><!--time.button-hover.post-date #[i.fas.fa-calendar-alt.article-icon(aria-hidden="true")] #[=__('post.modified')] #[=date(page['updated'], config.date_format)]--><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/python/">python</a></div></div></div><div class="main-content"><h2 id="一、类与对象"><a href="#一、类与对象" class="headerlink" title="一、类与对象"></a>一、类与对象</h2><h3 id="1-1-根类和元类"><a href="#1-1-根类和元类" class="headerlink" title="1.1 根类和元类"></a>1.1 根类和元类</h3><p>在python当中一切皆为对象，而在这当中有两个特别重要的概念：元类（meta class）和根类（root class）。对应两个基本类型<code>type</code>和<code>object</code>。</p>
<p>类型本身也是一种对象，它是的类型即为元类<code>type</code>。例如我们常见的内置数据类型<code>str、list、dict、int和float</code>等均为<code>type</code>的实例，如下示例。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> <span class="built_in">isinstance</span>(<span class="built_in">str</span>, <span class="built_in">type</span>)</span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">isinstance</span>(<span class="built_in">list</span>, <span class="built_in">type</span>)</span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">isinstance</span>(<span class="built_in">dict</span>, <span class="built_in">type</span>)</span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">isinstance</span>(<span class="built_in">int</span>, <span class="built_in">type</span>)</span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">isinstance</span>(<span class="built_in">object</span>, <span class="built_in">type</span>)</span><br></pre></td></tr></table></figure></p>
<p>而所有类型又都是根类object的直接或间接子类，继承了object的属性，如下示例<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> <span class="built_in">issubclass</span>(<span class="built_in">str</span>, <span class="built_in">object</span>)</span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">issubclass</span>(<span class="built_in">list</span>, <span class="built_in">object</span>)</span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">issubclass</span>(<span class="built_in">type</span>, <span class="built_in">object</span>)</span><br></pre></td></tr></table></figure><br><span id="more"></span><br>有心的人可以看到，object类是type类的实例对象，而type类又是object类的后继子类。那么先有<code>type</code>还是<code>object</code>呢？这是一个鸡和蛋问题。有兴趣可以去琢磨一下。</p>
<h3 id="1-2-python对象的创建"><a href="#1-2-python对象的创建" class="headerlink" title="1.2 python对象的创建"></a>1.2 python对象的创建</h3><p>大家很熟练地能够创建一个自定义类型并将其实例化。例如<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">myClass</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, initArgs:<span class="built_in">str</span></span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">myClassObj = myClass(<span class="string">&quot;initArgs&quot;</span>)</span><br></pre></td></tr></table></figure><br>那么请思考一下，在创建<code>myClassObj</code>时，我们只传递了<code>initArgs</code>这个参数，那么<code>self</code>参数是如何来的，它又是什么呢？这就涉及了python对象的创建过程了。<code>self</code>实际上就是<code>myClassObj</code>，它们指向的是一个内存地址。下面的示例可以看到两者具有一样的内存指向。也就是说，在传入<strong>init</strong>方法前，我们的对象已经被创立了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">myClass</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, initArgs:<span class="built_in">str</span></span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">id</span>(self))</span><br><span class="line"></span><br><span class="line">myClassObj = myClass(<span class="string">&quot;initArgs&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(myClassObj))</span><br><span class="line"><span class="comment"># 输出两行内存地址，结果一致</span></span><br></pre></td></tr></table></figure>
<p>请再思考，<code>myClass(&quot;initArgs&quot;)</code>直接调用的到底是什么方法？答案是myClass的元类<code>type</code>中<code>__call__</code>方法。下面是<code>type</code>的实现逻辑片段：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">type</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">cls: <span class="type">Type</span>, *args: <span class="type">Any</span>, **kwargs: <span class="type">Any</span></span>) -&gt; <span class="type">Any</span>:</span><br><span class="line">        self = cls.__new__(cls)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">hasattr</span>(self, <span class="string">&quot;__init__&quot;</span>):</span><br><span class="line">            self.__init__(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> self</span><br></pre></td></tr></table></figure></p>
<p>可以看出，当我们创建一个新的对象，首先调用了<code>__call__</code>方法，在python中，变量后直接根括号的语法，调用的是该变量类型的<code>__call__</code>方法，对类型对象，如前所述，类型也是<code>type</code>类的实例，故会调用<code>type.__call__</code>方法。而方法中调用了一个特殊方法<code>__new__</code>，默认继承<code>object.__new__</code>。它负责根据类型，创建对象实例，分配属性表和基础内存空间。也就是<code>self</code>的来源。最后才会用<code>__init__</code>初始化。</p>
<p>扩展知识：默认元类是type，但为了做一些扩展功能，可以自定义元类，例如<code>abc</code>库提供了<code>type</code>的子类<code>abc.ABCMeta</code>作为自定义元类，配合<code>abc.abstractmethod</code>等装饰器，可以做出类似java抽象接口的功能。自定义类可以用<code>metaclass</code>属性声明，例如在本人的SoCube项目中，定义了下列元类：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> Module</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NetMetaBase</span>(abc.ABCMeta):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self:<span class="type">Type</span>[Module], </span></span><br><span class="line"><span class="params">        inChannels:<span class="built_in">int</span>, </span></span><br><span class="line"><span class="params">        outChannels:<span class="built_in">int</span>, </span></span><br><span class="line"><span class="params">        *args: <span class="type">Any</span>, **kwargs: <span class="type">Any</span></span>) -&gt; Module:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        该方法创建self参数指定类的实例对象</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            self 即为NetMetaBase的实例，也就是以NetMetaBase为元类的类对象</span></span><br><span class="line"><span class="string">            </span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">issubclass</span>(self, Module), <span class="string">&quot;Class must be a subclass of torch.nn.Module&quot;</span></span><br><span class="line">        obj = self.__new__(self)</span><br><span class="line">        obj.__init__(inChannels, outChannels, *args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ModuleBase</span>(Module, metaclass=NetMetaBase):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, inChannels:<span class="built_in">int</span>, outChannels:<span class="built_in">int</span>, **kwargs</span>)-&gt;<span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">super</span>(ModuleBase, self).__init__()</span><br><span class="line">        self._inChannels = inChannels</span><br><span class="line">        self._outChannels = outChannels</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x:torch.Tensor</span>)-&gt;torch.Tensor:</span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br></pre></td></tr></table></figure></p>
<h3 id="1-3-python的多继承"><a href="#1-3-python的多继承" class="headerlink" title="1.3 python的多继承"></a>1.3 python的多继承</h3><p>python是支持多继承的，可以通过<code>class 新类名(类1, 类2, ...)</code>的形式继承。调用父类方法时利用<code>super</code>类控制，下列输出依次为A, B, C。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(self.__class__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(self.__class__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(A, B):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(C, self).__init__()</span><br><span class="line">        <span class="built_in">super</span>(A, self).__init__()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;C&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(self.__class__)</span><br><span class="line"></span><br><span class="line">C()</span><br><span class="line"><span class="keyword">assert</span> C.__mro__ == (C, A, B, <span class="built_in">object</span>)</span><br><span class="line"><span class="comment"># 输出如下</span></span><br><span class="line"><span class="comment"># A</span></span><br><span class="line"><span class="comment"># &lt;class &#x27;__main__.C&#x27;&gt;</span></span><br><span class="line"><span class="comment"># B</span></span><br><span class="line"><span class="comment"># &lt;class &#x27;__main__.C&#x27;&gt;</span></span><br><span class="line"><span class="comment"># C</span></span><br><span class="line"><span class="comment"># &lt;class &#x27;__main__.C&#x27;&gt;</span></span><br></pre></td></tr></table></figure><br>python继承是一个树结构，<code>super(cls, obj)</code>调用的是类别继承队列<code>__mro__</code>属性中，<code>cls</code>类后面的那个类，并将obj作为self参数传入，因此等价于<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">super</span>(C, self).__init__()</span><br><span class="line">A.__init__(self)</span><br></pre></td></tr></table></figure></p>
<h2 id="二、同步运算"><a href="#二、同步运算" class="headerlink" title="二、同步运算"></a>二、同步运算</h2><p>python支持多线程和多进程两种同步运算。其中由于全局解释器锁（GIL）的存在，python的多线程不能像java一样做到并行运算，发挥不出多核的优势。python的同步运算工具封装在<code>concurrent.futures</code>包中。</p>
<h3 id="2-1-单个线程的创建与使用"><a href="#2-1-单个线程的创建与使用" class="headerlink" title="2.1 单个线程的创建与使用"></a>2.1 单个线程的创建与使用</h3><p>Python2.X中使用<code>thread</code>模块进行多线程操作，它是一个比较初级的线程模块。而在Python3.X中，引入了<code>threading</code>模块，并将<code>thread</code>模块更名为<code>_thread</code>。<code>threading</code>模块具有更多高级特性。</p>
<p>thread模块使用<code>start_new_thread(function, args[, kwargs])</code>的API创建线程，function即新线程要运行的函数（类似于java中的Runnable接口），args是线程函数对应的参数，其为元组。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _thread <span class="keyword">as</span> th</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_time</span>(<span class="params"> threadName, delay</span>):</span><br><span class="line">   count = <span class="number">0</span></span><br><span class="line">   <span class="keyword">while</span> count &lt; <span class="number">5</span>:</span><br><span class="line">      time.sleep(delay)</span><br><span class="line">      count += <span class="number">1</span></span><br><span class="line">      <span class="built_in">print</span> (<span class="string">&quot;%s: %s&quot;</span> % ( threadName, time.ctime(time.time()) ))</span><br><span class="line"></span><br><span class="line">th.start_new_thread(print_time, (<span class="string">&quot;Thread-1&quot;</span>, <span class="number">2</span>))</span><br><span class="line">th.start_new_thread(print_time, (<span class="string">&quot;Thread-2&quot;</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><br>输出<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">139633559193344</span><br><span class="line">Thread-1: Mon Jun 28 12:53:50 2021Thread-2: Mon Jun 28 12:53:50 2021</span><br><span class="line"></span><br><span class="line">Thread-2: Mon Jun 28 12:53:52 2021</span><br><span class="line">Thread-1: Mon Jun 28 12:53:52 2021</span><br><span class="line">Thread-2: Mon Jun 28 12:53:54 2021</span><br><span class="line">Thread-1: Mon Jun 28 12:53:54 2021</span><br><span class="line">Thread-2: Mon Jun 28 12:53:56 2021</span><br><span class="line">Thread-1: Mon Jun 28 12:53:56 2021</span><br><span class="line">Thread-2: Mon Jun 28 12:53:58 2021</span><br><span class="line">Thread-1: Mon Jun 28 12:53:58 2021</span><br></pre></td></tr></table></figure></p>
<p>threading模块提供了更为丰富的线程实现，能够方便实现线程同步，保证线程安全。继承<code>threading.Thread</code>类来实现多线程，其模式与java的<code>java.lang.Thread</code>类实现多线程类似。</p>
<ul>
<li>run()<br>通过重写该方法实现自定义线程函数，等效于java的Thread.run方法</li>
<li>start()<br>通过该方法启动线程，实现了线程声明与启动的分离（前面thread模块的start_new_thread直接调用系统API创建并运行线程），等效于java的Thread.start方法</li>
<li>join([time])<br>通过该方法阻塞当前线程（指的是调用该函数时所在线程，而非创建的这个线程），直到创建的线程结束或等待超时，等效于java的Thread.join方法</li>
<li>getName()/setName()<br>线程名称<code>name</code>属性的getter/setter方法，当然可以直接对属性赋值，python没有变量封装，但这不是个好习惯</li>
<li>isAlive()<br>返回线程是否活动的。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">timeThread</span>(threading.Thread):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, threadName</span>):</span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        <span class="comment"># self.name = threadName</span></span><br><span class="line">        self.setName(threadName)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        print_time(self.getName(), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">thread1 = timeThread(<span class="string">&quot;Thread-1&quot;</span>)</span><br><span class="line">thread2 = timeThread(<span class="string">&quot;Thread-2&quot;</span>)</span><br><span class="line"></span><br><span class="line">thread1.start()</span><br><span class="line">thread2.start()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Two thread created and started&quot;</span>)</span><br><span class="line">thread1.join()</span><br><span class="line">thread2.join()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Main thread ended&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Two thread created and started</span><br><span class="line">Thread-1: Mon Jun 28 12:59:34 2021Thread-2: Mon Jun 28 12:59:34 2021</span><br><span class="line"></span><br><span class="line">Thread-1: Mon Jun 28 12:59:36 2021</span><br><span class="line">Thread-2: Mon Jun 28 12:59:36 2021</span><br><span class="line">Thread-1: Mon Jun 28 12:59:38 2021Thread-2: Mon Jun 28 12:59:38 2021</span><br><span class="line"></span><br><span class="line">Thread-1: Mon Jun 28 12:59:40 2021</span><br><span class="line">Thread-2: Mon Jun 28 12:59:40 2021</span><br><span class="line">Thread-1: Mon Jun 28 12:59:42 2021</span><br><span class="line">Thread-2: Mon Jun 28 12:59:42 2021</span><br><span class="line">Main thread ended</span><br></pre></td></tr></table></figure></p>
<h3 id="2-2-线程同步"><a href="#2-2-线程同步" class="headerlink" title="2.2 线程同步"></a>2.2 线程同步</h3><p><code>threading</code>的<code>Lock</code>或<code>RLock</code>可以提供线程锁，利用对应的<code>acquire</code>和<code>release</code>方法进行线程锁的控制。类似于java中的Lock接口（但和synchronized是不一样的）。当然，可以用with语句来简化，两个锁对象都实现了<code>__enter__</code>和<code>__exit__</code>函数，可以使用with语句，如<code>with lock</code>替代<code>acquire</code>和<code>release</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">timeLockThread</span>(threading.Thread):</span><br><span class="line">    lock = threading.Lock()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, threadName</span>):</span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.setName(threadName)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.getName(),<span class="string">&quot;准备获取锁&quot;</span>)</span><br><span class="line">        self.lock.acquire()</span><br><span class="line">        <span class="built_in">print</span>(self.getName(),<span class="string">&quot;获取锁成功&quot;</span>)</span><br><span class="line">        print_time(self.getName(), <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">print</span>(self.getName(),<span class="string">&quot;准备释放锁&quot;</span>)</span><br><span class="line">        self.lock.release()</span><br><span class="line">        <span class="built_in">print</span>(self.getName(),<span class="string">&quot;释放锁成功&quot;</span>)</span><br><span class="line"></span><br><span class="line">lockthread1 = timeLockThread(<span class="string">&quot;Thread-3&quot;</span>)</span><br><span class="line">lockthread2 = timeLockThread(<span class="string">&quot;Thread-4&quot;</span>)</span><br><span class="line"></span><br><span class="line">lockthread1.start()</span><br><span class="line">lockthread2.start()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Two thread created and started&quot;</span>)</span><br><span class="line">lockthread1.join()</span><br><span class="line">lockthread2.join()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Main thread ended&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Thread-3 准备获取锁</span><br><span class="line">Thread-3 获取锁成功</span><br><span class="line">Thread-4 准备获取锁</span><br><span class="line">Two thread created and started</span><br><span class="line">Thread-3: Mon Jun 28 13:17:26 2021</span><br><span class="line">Thread-3: Mon Jun 28 13:17:28 2021</span><br><span class="line">Thread-3: Mon Jun 28 13:17:30 2021</span><br><span class="line">Thread-3: Mon Jun 28 13:17:32 2021</span><br><span class="line">Thread-3: Mon Jun 28 13:17:34 2021</span><br><span class="line">Thread-3 准备释放锁</span><br><span class="line">Thread-3 释放锁成功</span><br><span class="line">Thread-4 获取锁成功</span><br><span class="line">Thread-4: Mon Jun 28 13:17:36 2021</span><br><span class="line">Thread-4: Mon Jun 28 13:17:38 2021</span><br><span class="line">Thread-4: Mon Jun 28 13:17:40 2021</span><br><span class="line">Thread-4: Mon Jun 28 13:17:42 2021</span><br><span class="line">Thread-4: Mon Jun 28 13:17:44 2021</span><br><span class="line">Thread-4 准备释放锁</span><br><span class="line">Thread-4 释放锁成功</span><br><span class="line">Main thread ended</span><br></pre></td></tr></table></figure></p>
<h3 id="2-3-线程池的使用"><a href="#2-3-线程池的使用" class="headerlink" title="2.3 线程池的使用"></a>2.3 线程池的使用</h3><p>单个线程的操作不利于线程的管理与复用。python提供了<code>concurrent.futures.ThreadPoolExecutor</code>来管理线程。它继承了<code>Executor</code>，实现了其一系列任务接口:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Executor</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;This is an abstract base class for concrete asynchronous executors.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">submit</span>(<span class="params">*args, **kwargs</span>)-&gt;Future:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">map</span>(<span class="params">self, fn, *iterables, timeout=<span class="literal">None</span>, chunksize=<span class="number">1</span></span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">shutdown</span>(<span class="params">self, wait=<span class="literal">True</span></span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span><br><span class="line">        self.shutdown(wait=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><br>使用十分简单<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, Future</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">a, b, sleeps = <span class="number">5</span></span>):</span><br><span class="line">    time.sleep(sleeps)</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">pool = ThreadPoolExecutor(max_workers = <span class="number">8</span>)</span><br><span class="line">task: Future = pool.submit(task, a = <span class="number">5</span>, b = <span class="number">6</span>, sleeps = <span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;a + b = <span class="subst">&#123;task.result&#125;</span>&quot;</span>)</span><br><span class="line">pool.shutdown(wait=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><br>上述方法会创建8个工作线程反复使用。同时可以看到Executor支持使用with上下文管理，方便自动释放资源。<code>pool.shutdown(wait=True)</code>意味着会等待任务完成再退出。</p>
<h3 id="2-4-进程池的使用"><a href="#2-4-进程池的使用" class="headerlink" title="2.4 进程池的使用"></a>2.4 进程池的使用</h3><p>如前所述，python的线程存在局限性，因此可以使用python的<code>multiprocessing</code>来进行多进程管理，同时python提供了进程池<code>concurrent.futures.ProcessPoolExecutor</code>来管理。它同样是<code>Executor</code>的子类，使用与线程池类似。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor, Future</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task1</span>(<span class="params">a, b, sleeps = <span class="number">5</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;PID is <span class="subst">&#123;os.getpid()&#125;</span>, PPID is <span class="subst">&#123;os.getppid()&#125;</span>&quot;</span>)</span><br><span class="line">    time.sleep(sleeps)</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;PID is <span class="subst">&#123;os.getpid()&#125;</span>&quot;</span>)</span><br><span class="line">    pool = ProcessPoolExecutor(max_workers = <span class="number">8</span>)</span><br><span class="line">    task: Future = pool.submit(task1, a = <span class="number">5</span>, b = <span class="number">6</span>, sleeps = <span class="number">6</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;a + b = <span class="subst">&#123;task.result()&#125;</span>&quot;</span>)</span><br><span class="line">    pool.shutdown(wait=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><br>会输出如下，可以看到在子进程27568中运行了task1。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PID is 11248</span><br><span class="line">PID is 27568, PPID is 11248</span><br><span class="line">a + b = 11</span><br></pre></td></tr></table></figure><br>但是多进程与多线程最大的不同在于进程是最小的资源单位，进程之间资源不共享。因此每个子进程需要重新加载用到的模块，包括当前执行脚本（即main模块）。我们将上述代码适当修改如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor, Future</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task1</span>(<span class="params">a, b, sleeps = <span class="number">5</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;PID is <span class="subst">&#123;os.getpid()&#125;</span>, PPID is <span class="subst">&#123;os.getppid()&#125;</span>&quot;</span>)</span><br><span class="line">    time.sleep(sleeps)</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Import <span class="subst">&#123;__name__&#125;</span> in PID is <span class="subst">&#123;os.getpid()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    pool = ProcessPoolExecutor(max_workers = <span class="number">8</span>)</span><br><span class="line">    task: Future = pool.submit(task1, a = <span class="number">5</span>, b = <span class="number">6</span>, sleeps = <span class="number">6</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;a + b = <span class="subst">&#123;task.result()&#125;</span>&quot;</span>)</span><br><span class="line">    pool.shutdown(wait=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><br>会得到如下输出，也就是<code>print(f&quot;Import &#123;__name__&#125; in PID is &#123;os.getpid()&#125;&quot;)</code>执行了9次，一次是启动程序的父进程，8次对应进程池的8个工作进程。当前脚本的模块名称分别是<code>__main__</code>和<code>__mp_main__</code>。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Import __main__ in PID is 30336</span><br><span class="line">Import __mp_main__ in PID is 18740</span><br><span class="line">Import __mp_main__ in PID is 31404</span><br><span class="line">Import __mp_main__ in PID is 16500</span><br><span class="line">Import __mp_main__ in PID is 20584</span><br><span class="line">PID is 18740, PPID is 30336</span><br><span class="line">Import __mp_main__ in PID is 36504</span><br><span class="line">Import __mp_main__ in PID is 2624</span><br><span class="line">Import __mp_main__ in PID is 12776</span><br><span class="line">Import __mp_main__ in PID is 5780</span><br><span class="line">a + b = 11</span><br></pre></td></tr></table></figure><br>设想一下，如果将创建多进程的代码，也就是<code>if __name__ == &quot;__main__&quot;</code>下面的代码块不放在这个条件下，那么则会无限递归地创建新进程。因此python禁止了这样的操作。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor, Future</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task1</span>(<span class="params">a, b, sleeps = <span class="number">5</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;PID is <span class="subst">&#123;os.getpid()&#125;</span>, PPID is <span class="subst">&#123;os.getppid()&#125;</span>&quot;</span>)</span><br><span class="line">    time.sleep(sleeps)</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Import <span class="subst">&#123;__name__&#125;</span> in PID is <span class="subst">&#123;os.getpid()&#125;</span>&quot;</span>)</span><br><span class="line">pool = ProcessPoolExecutor(max_workers = <span class="number">8</span>)</span><br><span class="line">task: Future = pool.submit(task1, a = <span class="number">5</span>, b = <span class="number">6</span>, sleeps = <span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;a + b = <span class="subst">&#123;task.result()&#125;</span>&quot;</span>)</span><br><span class="line">pool.shutdown(wait=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><br>上述代码会抛出<code>RuntimeError</code>，提示<code>An attempt has been made to start a new process before the current process has finished its bootstrapping phase</code>。即不能在当前进程加载模块的时候创建子进程。<br>在使用时，务必在上述if语句下控制。因为我们看到子进程的模块名称是<code>__mp_main__</code>而非<code>__main__</code>了，因此不在存在这个问题。<br>另外需要注意的一点是，多进程将一个可执行对象submit，本质上是利用了进程之间的IPC通信，那么实际上时将这个执行性对象利用<code>pickle</code>序列化后传输给子进程，由子进程反序列化并执行，因此需要满足序列化的要求，即对象一致性。例如下列情况就会抛出<code>picke_error</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor, Future</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parallel</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">      @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">      <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            pool = ProcessPoolExecutor(max_workers=<span class="number">2</span>)</span><br><span class="line">            task = pool.submit(func, *args, **kwargs)</span><br><span class="line">            <span class="keyword">return</span> task</span><br><span class="line">      <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@parallel</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task1</span>(<span class="params">a, b, sleeps = <span class="number">5</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;PID is <span class="subst">&#123;os.getpid()&#125;</span>, PPID is <span class="subst">&#123;os.getppid()&#125;</span>&quot;</span>)</span><br><span class="line">    time.sleep(sleeps)</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    task: Future = task1(a=<span class="number">5</span>, b= <span class="number">6</span>)</span><br><span class="line">    <span class="built_in">print</span>(task.result())</span><br></pre></td></tr></table></figure><br>上述代码会报错<code>_pickle.PicklingError: Can&#39;t pickle &lt;function task1 at 0x000001A9FA495310&gt;: it&#39;s not the same object as __main__.task1</code>。这是因为task1被装饰了，而不是提交任务的那个task1。</p>
</div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-meta">本文作者: </span><span class="post-copyright-info"><a href="mailto:undefined">GCS-ZHN</a></span></div><div class="post-copyright-type"><span class="post-copyright-meta">本文链接: </span><span class="post-copyright-info"><a href="https://gcszhn.top/2022/04/17/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">https://gcszhn.top/2022/04/17/python学习笔记/</a></span></div><div class="post-copyright-notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://gcszhn.top">潇洒记忆</a>！</span></div></div></article><div id="pagination"><div class="prev-post pull-left"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/2022/04/20/clash/"><i class="fas fa-angle-left">&nbsp;</i><span>基于Clash配置linux服务器代理</span></a></div><div class="next-post pull-right"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/2022/04/16/anaconda/"><span>anaconda学习笔记</span><span>&nbsp;</span><i class="fas fa-angle-right"></i></a></div></div><!--div!= paginator()--></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-file-o"></i></span><span id="busuanzi_value_page_pv"></span><span></span></div><div class="copyright">&copy;2017 ～ 2022 By GCS-ZHN</div><a href="https://beian.miit.gov.cn/" target="_blank">&nbsp; 浙ICP备2022014039号</a></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--></body></html>