<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Cython学习笔记"><meta name="keywords" content="python,cython,cpp,c++,c,扩展"><meta name="author" content="GCS-ZHN,undefined"><meta name="copyright" content="GCS-ZHN"><title>Cython学习笔记【潇洒记忆】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><link rel="icon" href="/favicon.ico"><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- script(src=url_for("/js/mathjax/mathjax.js"))--><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  gitment: {},
  valine: {},
}</script><meta name="generator" content="Hexo 6.0.0"></head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="toggle-sidebar-info button-hover"><span data-toggle="文章目录">站点概览</span></div><div class="sidebar-toc"><div class="sidebar-toc-title">目录</div><div class="sidebar-toc-progress"><span class="progress-notice">您已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc-progress-bar"></div></div><div class="sidebar-toc-content" id="sidebar-toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81Cython%E5%AE%89%E8%A3%85%E4%B8%8E%E7%BC%96%E8%AF%91"><span class="toc-number">1.</span> <span class="toc-text">一、Cython安装与编译</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-Cython%E5%AE%89%E8%A3%85"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 Cython安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-Cython%E7%BC%96%E8%AF%91"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 Cython编译</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Cython%E5%9F%BA%E7%A1%80"><span class="toc-number">2.</span> <span class="toc-text">二、Cython基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E5%8F%98%E9%87%8F%E4%B8%8E%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 变量与类型声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-Python%E5%87%BD%E6%95%B0%E5%92%8CC%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 Python函数和C函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-Cython%E4%B8%AD%E7%9A%84C%E6%8C%87%E9%92%88%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 Cython中的C指针与类型转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81Cython%E4%B8%AD%E4%BD%BF%E7%94%A8C"><span class="toc-number">3.</span> <span class="toc-text">三、Cython中使用C++</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-Vector%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8"><span class="toc-number">3.1.</span> <span class="toc-text">2.1 Vector容器使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Cython%E4%B8%8EC%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-number">4.</span> <span class="toc-text">四、Cython与C表达式的差异</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91"><span class="toc-number">5.</span> <span class="toc-text">五、条件编译</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E7%BC%96%E8%AF%91%E6%97%B6%E5%AE%9A%E4%B9%89"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 编译时定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 条件语句</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%BC%95%E7%94%A8%E5%A4%96%E9%83%A8C-C-%E6%96%87%E4%BB%B6"><span class="toc-number">6.</span> <span class="toc-text">六、引用外部C&#x2F;C++文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E3%80%81Python%E6%89%A9%E5%B1%95%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.</span> <span class="toc-text">七、Python扩展对象类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-PyObject%E5%92%8CPyTypeObject"><span class="toc-number">7.1.</span> <span class="toc-text">7.1 PyObject和PyTypeObject</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-%E5%88%A9%E7%94%A8Cython%E8%87%AA%E5%AE%9A%E4%B9%89Python%E6%89%A9%E5%B1%95%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.2.</span> <span class="toc-text">7.2 利用Cython自定义Python扩展类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-%E8%8E%B7%E5%8F%96Python%E5%AF%B9%E8%B1%A1%E5%86%85%E9%83%A8C-C-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">7.3.</span> <span class="toc-text">7.3 获取Python对象内部C&#x2F;C++数据结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E3%80%81Cython%E9%A2%84%E5%AE%9A%E4%B9%89%E7%9A%84C-C-%E6%A0%87%E5%87%86%E5%BA%93"><span class="toc-number">8.</span> <span class="toc-text">七、Cython预定义的C&#x2F;C++标准库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E7%94%A8Cython%E6%89%A9%E5%B1%95%E4%BD%BF%E7%94%A8Numpy"><span class="toc-number">9.</span> <span class="toc-text">八、用Cython扩展使用Numpy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E7%94%A8Cython%E6%89%A9%E5%B1%95%E4%BD%BF%E7%94%A8Torch"><span class="toc-number">10.</span> <span class="toc-text">九、用Cython扩展使用Torch</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-Torch%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-number">10.1.</span> <span class="toc-text">9.1 Torch的配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-Python%E7%B1%BB%E5%9E%8BTensor%E8%BD%AC%E4%B8%BAC-%E7%B1%BB%E5%9E%8B"><span class="toc-number">10.2.</span> <span class="toc-text">9.2 Python类型Tensor转为C++类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="toc-number">11.</span> <span class="toc-text">参考文献</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/avatar.png"></div><div class="author-info-name">GCS-ZHN</div><div class="author-info-description"></div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/GCS-ZHN" target="_blank">GitHub<i class="icon-dot bg-color8"></i></a><a class="links-button button-hover" href="mailto:zhang.h.n@foxmail.com" target="_blank">E-Mail<i class="icon-dot bg-color8"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/archives"><span class="pull-top">日志</span><span class="pull-bottom">22</span></a><a class="author-info-articles-tags article-meta" href="/tags"><span class="pull-top">标签</span><span class="pull-bottom">47</span></a><a class="author-info-articles-categories article-meta" href="/categories"><span class="pull-top">分类</span><span class="pull-bottom">15</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/archives">归档</a></nav><div class="right-info"><a class="title-name" href="/">潇洒记忆</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="title">Cython学习笔记</div><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 发表于 2021-03-15 | 更新于 2022-08-01</time><!--time.button-hover.post-date #[i.fas.fa-calendar-alt.article-icon(aria-hidden="true")] #[=__('post.modified')] #[=date(page['updated'], config.date_format)]--><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/python/">python</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/cython/">cython</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/cpp/">cpp</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/c/">c++</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/c/">c</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E6%89%A9%E5%B1%95/">扩展</a></div></div></div><div class="main-content"><h3 id="一、Cython安装与编译"><a href="#一、Cython安装与编译" class="headerlink" title="一、Cython安装与编译"></a>一、Cython安装与编译</h3><p>Cython能够扩展Python，使用C/C++代码来实现对C/C++的调用。</p>
<ul>
<li>pyx文件：cython源代码文件</li>
<li>pxd文件：cython自己的库文件，通过cimport进行调用</li>
<li>pyd文件：cython编译后产生的python库，python中import进行使用，主要用于定义C/C++类型</li>
<li>pxi文件：类似于C/C++的头文件，通过include进行文本包含</li>
<li>setup.py：将cython编译的工具</li>
</ul>
<h4 id="1-1-Cython安装"><a href="#1-1-Cython安装" class="headerlink" title="1.1 Cython安装"></a>1.1 Cython安装</h4><p>通过pip命令安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install Cython</span><br></pre></td></tr></table></figure></p>
<h4 id="1-2-Cython编译"><a href="#1-2-Cython编译" class="headerlink" title="1.2 Cython编译"></a>1.2 Cython编译</h4><p>（1）通过setup.py工具编译，文件代码如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> setuptools <span class="keyword">import</span> setup</span><br><span class="line"><span class="keyword">from</span> Cython.Build <span class="keyword">import</span> cythonize</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    name=<span class="string">&#x27;Hello world app&#x27;</span>, //对应最后生成的python库名</span><br><span class="line">    ext_modules=cythonize(<span class="string">&quot;hello.pyx&quot;</span>), //对应cython源文件名</span><br><span class="line">    zip_safe=<span class="literal">False</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br><span id="more"></span><br>再通过<code>python setup.py build_ext --inplace</code>编译</p>
<p>（2）在jupyter notebook中，可以通过魔法函数直接运行cython<br><figure class="highlight ipython"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">%load_ext Cython <span class="comment">#加载Cython组件</span></span><br><span class="line"></span><br><span class="line">%%cython <span class="comment">#表示当前单元格是cython代码</span></span><br><span class="line"></span><br><span class="line">cdef <span class="built_in">int</span> a = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    a += i</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure></p>
<h3 id="二、Cython基础"><a href="#二、Cython基础" class="headerlink" title="二、Cython基础"></a>二、Cython基础</h3><p>注意Cython语法是不同于Python/C/C++的独立语法格式，Cython编译工具负责将其转换为C/C++代码，并编译为pyd库。相比直接用C/C++写，更加简便，不用深入了解Python的C类型定义。</p>
<h4 id="2-1-变量与类型声明"><a href="#2-1-变量与类型声明" class="headerlink" title="2.1 变量与类型声明"></a>2.1 变量与类型声明</h4><p>（1）函数形参的C类型声明<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">primes</span>(<span class="params"><span class="built_in">int</span> nb_primes</span>): <span class="comment">## int表示参数类型为C的int类型</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><br>（2）局部C类型声明</p>
<p>C类型声明主要使用cdef关键字。此外，cython中使用ctypedef来定义组合类型，等同于C/C++的typedef关键字。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ctypedef unsigned long ULong <span class="comment">## 定义组合类型无符号长整型ULong</span></span><br><span class="line"></span><br><span class="line">cdef <span class="built_in">int</span> n, i, len_p <span class="comment">## Cint</span></span><br><span class="line">cdef <span class="built_in">int</span> p[<span class="number">1000</span>]     <span class="comment">## C数组         </span></span><br><span class="line">p[:<span class="number">4</span>]                <span class="comment">## 部分Cython版本支持同Python数组一样的切片</span></span><br><span class="line"></span><br><span class="line">cdef <span class="built_in">int</span> eggs(unsigned long l, <span class="built_in">float</span> f): <span class="comment">## c函数定义，python中无法直接调用</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">cdef <span class="keyword">class</span> <span class="title class_">Shrubbery</span>:  <span class="comment">## 利用C结构体存储类，比python类更快，定义类的语法与python相似。其实在C++中，类与结构体基本一样了。</span></span><br><span class="line">    cdef <span class="built_in">int</span> width, height</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, w, h</span>):</span><br><span class="line">        self.width = w</span><br><span class="line">        self.height = h</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">describe</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;This shrubbery is&quot;</span>, self.width,</span><br><span class="line">            <span class="string">&quot;by&quot;</span>, self.height, <span class="string">&quot;cubits.&quot;</span>)</span><br></pre></td></tr></table></figure><br>（3）支持的C数据类型</p>
<p>支持char、short、int、long、long long及其unsigned版本，支持enum、struct和union这种复合数据结构。对于bool类型，使用bint来声明。对于size_t，Cython中等效使用Py_ssize_t类型。</p>
<p>（4）常见python类型的静态声明</p>
<p>常见的python内置类型如list、dict、tuple等可以通过cdef，与C类型一样在编译时声明。为<code>PyObject*</code>指针类型，但<code>int、float、long</code>这种python类型，会直接用C类型代替。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cdef <span class="built_in">list</span> foo = [] <span class="comment">## Python 列表</span></span><br><span class="line">cdef (double, <span class="built_in">int</span>) bar <span class="comment">## ctuple类型，对应tuple</span></span><br></pre></td></tr></table></figure><br>（5）组合声明<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line">cdef:</span><br><span class="line">    struct Spam:</span><br><span class="line">        <span class="built_in">int</span> tons</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> i</span><br><span class="line">    <span class="built_in">float</span> a</span><br><span class="line">    Spam *p</span><br><span class="line"></span><br><span class="line">    void f(Spam *s):</span><br><span class="line">        <span class="built_in">print</span>(s.tons, <span class="string">&quot;Tons of spam&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<h4 id="2-2-Python函数和C函数"><a href="#2-2-Python函数和C函数" class="headerlink" title="2.2 Python函数和C函数"></a>2.2 Python函数和C函数</h4><p>Cython中，<code>def</code>定义的函数能够被Python解释器调用，函数可以是Python对象或者C类型。Cython会根据参数是否包含类型声明来判断是哪种参数类型。也可以用<code>object</code>显式声明为Python类型<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">spam</span>(<span class="params"><span class="built_in">int</span> i, char *s</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spam</span>(<span class="params">python_i, python_s</span>): <span class="comment">##等价于这个函数</span></span><br><span class="line">    cdef <span class="built_in">int</span> i = python_i</span><br><span class="line">    cdef char* s = python_s</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spam</span>(<span class="params"><span class="built_in">object</span> python_i, <span class="built_in">object</span> python_s</span>): <span class="comment">##显式声明为Python类型参数</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><br>值得注意的是，C类型为参数实际上进行了一次Python对象转C类型的转换。根据Cython限制，这种<strong>自动转换仅限于字符串、数值、结构体及它们的组合类型</strong>。其他类型会导致编译错误。</p>

	<img src="/2021/03/15/cython/autoTypeConversion.png" class="" title="自动转换">

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> cpython.ref cimport PyObject</span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line">cdef PyObject * obj = NULL</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setObj</span>(<span class="params">newobj</span>):</span><br><span class="line">    <span class="keyword">global</span> obj</span><br><span class="line">    obj = &lt;PyObject *&gt;newobj <span class="comment">## 转为指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getObj</span>():</span><br><span class="line">    <span class="keyword">global</span> obj</span><br><span class="line">    <span class="built_in">print</span>(&lt;<span class="built_in">object</span>&gt; obj) <span class="comment">## 转为Python对象</span></span><br><span class="line"></span><br><span class="line">array = [<span class="number">1</span>,<span class="number">23</span>,<span class="number">5</span>]</span><br><span class="line">setObj(array)</span><br><span class="line">array[<span class="number">1</span>] = <span class="number">5</span></span><br><span class="line">getObj() <span class="comment">## 输出为[1,5,5]</span></span><br></pre></td></tr></table></figure>
<p>Cython中，<code>cdef</code>定义的函数可以声明C类型的函数，但这个函数无法被Python解释器直接调用。C类型函数有返回值。其参数可以是C或Python类型。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cdef <span class="built_in">int</span> eggs(unsigned long l, <span class="built_in">float</span> f):<span class="comment">## c int返回值</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">cdef (<span class="built_in">int</span>, <span class="built_in">float</span>) chips((long, long, double) t): <span class="comment">## ctuple返回值</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><br>cdef函数返回值分为Python和C类型，当没有显示的return语句，具有以下默认返回值</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">returnType</th>
<th style="text-align:left">Default</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Python Object</td>
<td style="text-align:left">None</td>
</tr>
<tr>
<td style="text-align:left">int</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">bint</td>
<td style="text-align:left">False</td>
</tr>
<tr>
<td style="text-align:left">pointer type</td>
<td style="text-align:left">NULL</td>
</tr>
</tbody>
</table>
</div>
<p>对于def的函数，返回类型是PyObject，当发生错误时会自动返回错误码NULL。但是对应cdef函数来说，需要通过except关键字设定默认返回C类型。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cdef <span class="built_in">int</span> spam() <span class="keyword">except</span> -<span class="number">1</span>:   <span class="comment">## 代表返回-1时为ERROR状态，此时Python解释器会抛出Error</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">cdef <span class="built_in">int</span> spam() <span class="keyword">except</span>? -<span class="number">1</span>:  <span class="comment">##？代表返回值-1可能是因为错误产生，会调用Python的C API  PyErr_Occurred()来验证是否有error产生。若是，抛出Error。不是则将-1正常返回</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">cdef <span class="built_in">int</span> spam() <span class="keyword">except</span> *:    <span class="comment">## 不论返回值是什么，都调用PyErr_Occurred()来验证是否有error产生。</span></span><br><span class="line"></span><br><span class="line">cdef <span class="built_in">int</span> spam() <span class="keyword">except</span> +     <span class="comment">## 可能抛出错误的外部C++函数的Cython对应函数声明</span></span><br></pre></td></tr></table></figure><br>注意：上述异常返回值，仅限于返回类型为<code>int、enum、float和指针</code>的函数，且值必须为常量表达式。对应<code>void</code>类型，只能使用<code>except *</code>。异常返回属于函数签名的一部分。</p>
<p>注意：cdef函数若没声明返回类型，默认会返回一个PyObject</p>
<p>以上的异常检查针对的是Python或Cython函数，但对外部引用的非Cython函数（如fopen这个C函数），是无效的。因为这个功能实际上是Cython在转写为C代码是对函数体利用Python C API进行异常处理<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cdef <span class="keyword">extern</span> FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">char</span> *filename, <span class="type">char</span> *mode)</span> except <span class="literal">NULL</span> <span class="comment">// WRONG!</span></span><br></pre></td></tr></table></figure><br>因此，需要自行判断处理，例如以下例子<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> libc.stdio cimport FILE, fopen, printf</span><br><span class="line"><span class="keyword">from</span> cpython.exc cimport PyErr_SetFromErrnoWithFilenameObject</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">open_file</span>(<span class="params">char * file</span>):</span><br><span class="line">    cdef FILE* p</span><br><span class="line">    p = fopen(file, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> p <span class="keyword">is</span> NULL:</span><br><span class="line">        PyErr_SetFromErrnoWithFilenameObject(OSError, file)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        printf(<span class="string">&quot;Hello, %s, file %s found&quot;</span>, <span class="string">&quot;GCS-ZHN&quot;</span>, file)</span><br></pre></td></tr></table></figure><br>除了<code>cdef和def</code>,Cython中还支持cpdef，cpdef会让Cython同时有这个函数的cdef和def版本，在Cython中利用cdef函数，而python可以调用def版本。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cpdef <span class="built_in">int</span> divide(<span class="built_in">int</span> a, <span class="built_in">int</span> b) <span class="keyword">except</span> ? -<span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> a/b</span><br></pre></td></tr></table></figure><br>cpdef方法可以覆盖同名方法，此外Python类中的def方法可以覆盖cpdef同名方法，但不能覆盖cdef方法</p>
<h4 id="2-3-Cython中的C指针与类型转换"><a href="#2-3-Cython中的C指针与类型转换" class="headerlink" title="2.3 Cython中的C指针与类型转换"></a>2.3 Cython中的C指针与类型转换</h4><p>（1）C类型的引用与解引用<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cdef double k = <span class="number">5.2</span></span><br><span class="line">cdef double *pd = &amp;k <span class="comment">## 获取引用</span></span><br><span class="line"><span class="built_in">print</span>(k) <span class="comment">## 5.2</span></span><br><span class="line">pd[<span class="number">0</span>] = <span class="number">10</span> <span class="comment">## 通过索引0来对指针解引用，因为*号已经被Python使用在不定参数解析上</span></span><br><span class="line">pd[<span class="number">2</span>] <span class="comment">## 指针偏移两字节的地址解引用，但一般一个变量占据字节数不一定，故需要根据C语言的sizeof进行对应处理，如pd[2*i]。</span></span><br><span class="line"><span class="built_in">print</span>(k) <span class="comment">## 10</span></span><br></pre></td></tr></table></figure><br>（2）强制转换</p>
<p>Cython中使用<code>&lt;&gt;</code>代替C中的<code>()</code>进行类型强制转换，下面是来自官方文档的示例。除了前述几种python类型，其他类型需要转为C类型时，需要进行强制转换，如<code>PyObject * obj = &lt;PyObject *&gt; list()</code>转换了一个空列表。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> cpython.ref cimport PyObject</span><br><span class="line"></span><br><span class="line">cdef extern <span class="keyword">from</span> *:</span><br><span class="line">    ctypedef Py_ssize_t Py_intptr_t</span><br><span class="line"></span><br><span class="line">python_string = <span class="string">&quot;foo&quot;</span></span><br><span class="line"></span><br><span class="line">cdef void* ptr = &lt;void*&gt;python_string <span class="comment">## python字符串需要默认自动转成char *，这里进一步转换为void *</span></span><br><span class="line">cdef Py_intptr_t adress_in_c = &lt;Py_intptr_t&gt;ptr</span><br><span class="line">address_from_void = adress_in_c        <span class="comment"># address_from_void is a python int</span></span><br><span class="line"></span><br><span class="line">cdef PyObject* ptr2 = &lt;PyObject*&gt;python_string</span><br><span class="line">cdef Py_intptr_t address_in_c2 = &lt;Py_intptr_t&gt;ptr2</span><br><span class="line">address_from_PyObject = address_in_c2  <span class="comment"># address_from_PyObject is a python int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> address_from_void == address_from_PyObject == <span class="built_in">id</span>(python_string)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(&lt;<span class="built_in">object</span>&gt;ptr)                     <span class="comment"># Prints &quot;foo&quot;，&lt;object&gt;将指针转回python对象，此外还可以用&lt;list&gt;等python类型进行转换</span></span><br><span class="line"><span class="built_in">print</span>(&lt;<span class="built_in">object</span>&gt;ptr2)                    <span class="comment"># prints &quot;foo&quot;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="三、Cython中使用C"><a href="#三、Cython中使用C" class="headerlink" title="三、Cython中使用C++"></a>三、Cython中使用C++</h3><p>部分C++标准库已经内置在Cython库中，可以直接导入使用.由于Cython默认编译为C代码，因此需要开头特别指明为C++。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># distutils: language=c++</span></span><br></pre></td></tr></table></figure></p>
<h4 id="2-1-Vector容器使用"><a href="#2-1-Vector容器使用" class="headerlink" title="2.1 Vector容器使用"></a>2.1 Vector容器使用</h4><p>通过下列语句导入C++容器vector。将vector容器作为def定义的python函数返回值时，会自动转换为python的列表list<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> libcpp.vector cimport vector</span><br></pre></td></tr></table></figure></p>
<h3 id="四、Cython与C表达式的差异"><a href="#四、Cython与C表达式的差异" class="headerlink" title="四、Cython与C表达式的差异"></a>四、Cython与C表达式的差异</h3>
	

<p>一方面，Cython中解引用使用索引代替*，另一方面，指针操作符“-&gt;”统一被“.”代替。</p>
<h3 id="五、条件编译"><a href="#五、条件编译" class="headerlink" title="五、条件编译"></a>五、条件编译</h3><h4 id="5-1-编译时定义"><a href="#5-1-编译时定义" class="headerlink" title="5.1 编译时定义"></a>5.1 编译时定义</h4><p>与C/C++的<code>#defined</code>定义预处理的常量宏类似，可以通过<code>DEF</code>定义一些编译时常量，这些常量在编译后会被替换为具体值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 因为是编译时替换，故必须是常量表达式</span></span><br><span class="line">DEF FavouriteFood = <span class="string">u&quot;spam&quot;</span></span><br><span class="line">DEF ArraySize = <span class="number">42</span></span><br><span class="line">DEF OtherArraySize = <span class="number">2</span> * ArraySize + <span class="number">17</span></span><br></pre></td></tr></table></figure><br>常见内置常量宏有<code>UNAME_SYSNAME, UNAME_NODENAME, UNAME_RELEASE, UNAME_VERSION, UNAME_MACHINE</code>。这些常量宏由Cython编译器自动定义。</p>
<h4 id="5-2-条件语句"><a href="#5-2-条件语句" class="headerlink" title="5.2 条件语句"></a>5.2 条件语句</h4><p>类似C/C++的<code>#ifndef、#elif和#endif</code>的宏命令，可以通过<code>IF、ELIF和ELSE</code>的Cython宏命令实现条件编译。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IF UNAME_SYSNAME == <span class="string">&quot;Windows&quot;</span>:</span><br><span class="line">    include <span class="string">&quot;icky_definitions.pxi&quot;</span></span><br><span class="line">ELIF UNAME_SYSNAME == <span class="string">&quot;Darwin&quot;</span>:</span><br><span class="line">    include <span class="string">&quot;nice_definitions.pxi&quot;</span></span><br><span class="line">ELIF UNAME_SYSNAME == <span class="string">&quot;Linux&quot;</span>:</span><br><span class="line">    include <span class="string">&quot;penguin_definitions.pxi&quot;</span></span><br><span class="line">ELSE:</span><br><span class="line">    include <span class="string">&quot;other_definitions.pxi&quot;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="六、引用外部C-C-文件"><a href="#六、引用外部C-C-文件" class="headerlink" title="六、引用外部C/C++文件"></a>六、引用外部C/C++文件</h3><p>（1）引用自定义C/C++文件<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cdef <span class="keyword">extern</span> from <span class="string">&quot;test.h&quot;</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printf</span><span class="params">(<span class="type">char</span> *name)</span> ## 只需要声明使用函数，其作用在于告诉Cython有这个函数。头文件由C/C++编译器负责解析</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">cdef <span class="keyword">extern</span> from &quot;Person.hpp&quot;:</span></span><br><span class="line"><span class="function">cdef cppclass Person:  ## 用cppclass关键字说明是C++类</span></span><br><span class="line"><span class="function">    Person(string, string) except +</span></span><br><span class="line"><span class="function">    void printName()</span></span><br><span class="line"><span class="function">    void printID()</span></span><br></pre></td></tr></table></figure><br>（2）使用C/C++标准库</p>
<p>同C/C++ 的<code>#include</code>，使用<code>&lt;&gt;</code>表示为标准库。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cdef <span class="keyword">extern</span> from <span class="string">&quot;&lt;string&gt;&quot;</span> <span class="keyword">namespace</span> <span class="string">&quot;std&quot;</span>:</span><br><span class="line">    cdef cppclass string:</span><br><span class="line">        <span class="built_in">string</span>(<span class="type">char</span> *) except+ <span class="comment">// 同样只需声明Cython中用到的函数</span></span><br></pre></td></tr></table></figure><br>此外，Cython预置了常见的C/C++标准库，使用方法如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> libcpp.string cimport string <span class="comment">## 导入c++标准模板库string下的string类</span></span><br><span class="line"><span class="keyword">from</span> libc.stdio cimport printf <span class="comment">## 导入C标准库stdio下的printf方法</span></span><br></pre></td></tr></table></figure><br>（3）创建C++对象</p>
<p>同C++一样，使用new创建对象指针，指向堆上的对象，需要使用<code>del</code>手动释放内存（等同于C++的delete或C的free）。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cdef Person * person = <span class="keyword">new</span> <span class="built_in">Person</span>((<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;zhn&quot;</span>))[<span class="number">0</span>],  (<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;22060229&quot;</span>))[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><br>也可以同C++那样直接在栈内存上创建对象，无需手动释放内存<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cdef Person person = <span class="built_in">Person</span>(<span class="built_in">string</span>(<span class="string">&quot;zhn&quot;</span>), <span class="built_in">string</span>(<span class="string">&quot;22060229))</span></span><br></pre></td></tr></table></figure><br>（4）重载方法与重载运算符</p>
<p>C++中支持对对象方法的重载和对运算操作符的重载，Cython中对此予以支持实现<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 构造方法的重载</span></span><br><span class="line">cdef extern <span class="keyword">from</span> <span class="string">&quot;..\lib\head\Person.hpp&quot;</span>:</span><br><span class="line">    cdef cppclass Person:</span><br><span class="line">        Person() <span class="keyword">except</span>+ </span><br><span class="line">        Person(string name, string <span class="built_in">id</span>) <span class="keyword">except</span>+</span><br><span class="line"></span><br><span class="line"><span class="comment">## 运算符重载</span></span><br><span class="line"><span class="comment"># distutils: language = c++</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cython.operator库下包含了一些特殊的c++运算符替代函数，用于重载C++运算符</span></span><br><span class="line"><span class="comment"># 例如python本身不支持的++运算符，python另有他用的*和**运算符</span></span><br><span class="line"><span class="keyword">from</span> cython.operator cimport preincrement <span class="keyword">as</span> prei <span class="comment">## ++a</span></span><br><span class="line"><span class="keyword">from</span> cython.operator cimport postincrement <span class="keyword">as</span> posti <span class="comment">## a++</span></span><br><span class="line"><span class="keyword">from</span> cython.operator cimport dereference <span class="keyword">as</span> der <span class="comment">## *a，解引用，不过可以如前用索引[0]</span></span><br><span class="line"><span class="keyword">from</span> cython.operator cimport predecrement <span class="keyword">as</span> pred <span class="comment">## --a</span></span><br><span class="line"><span class="keyword">from</span> cython.operator cimport postdecrement <span class="keyword">as</span> postd <span class="comment">## a--</span></span><br><span class="line"><span class="keyword">from</span> cython.operator cimport comma <span class="keyword">as</span> comma <span class="comment">## (a, b) 括号运算</span></span><br><span class="line"><span class="keyword">from</span> cython.operator cimport address <span class="keyword">as</span> addr <span class="comment">## &amp;a，取指针，当然cython本身支持&amp;a运算</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 在cython中引入STL的vector模板类</span></span><br><span class="line"><span class="comment">## from libcpp.vector cimport vector ## 其实vector作为STL重要组成，已被cython内置</span></span><br><span class="line">cdef extern <span class="keyword">from</span> <span class="string">&quot;&lt;vector&gt;&quot;</span> namespace <span class="string">&quot;std&quot;</span>:</span><br><span class="line">    <span class="comment">## 使用“[]”声明泛型（模板）参数</span></span><br><span class="line">    cdef cppclass vector[T]: </span><br><span class="line">        cppclass iterator:</span><br><span class="line">            T operator*()</span><br><span class="line">            iterator operator++()   <span class="comment">## ++运算符重载</span></span><br><span class="line">            iterator operator++(<span class="built_in">int</span>) <span class="comment">## ++运算符后置重载</span></span><br><span class="line">            bint operator==(iterator) <span class="comment">## ==运算符重载</span></span><br><span class="line">            bint operator!=(iterator) <span class="comment">## !=运算符重载</span></span><br><span class="line"></span><br><span class="line">        vector(T *) <span class="keyword">except</span>+</span><br><span class="line">        vector() <span class="keyword">except</span>+</span><br><span class="line">        void push_back(T&amp;)</span><br><span class="line">        T&amp; operator[](<span class="built_in">int</span>)</span><br><span class="line">        T&amp; at(<span class="built_in">int</span>)</span><br><span class="line">        iterator begin()</span><br><span class="line">        iterator end()</span><br><span class="line">        Py_ssize_t size()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">array</span>):</span><br><span class="line">    cdef vector[<span class="built_in">int</span>] v1</span><br><span class="line">    <span class="built_in">print</span>(v1.size())</span><br><span class="line">    <span class="keyword">for</span> val <span class="keyword">in</span> array:</span><br><span class="line">        v1.push_back(val)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(v1.size()==<span class="built_in">len</span>(array))</span><br><span class="line">    <span class="built_in">print</span>(v1[v1.size()-<span class="number">1</span>])</span><br><span class="line">    <span class="built_in">print</span>(der(v1.begin()))</span><br><span class="line">    <span class="comment">#print(&lt;int&gt;v1.begin()[0])</span></span><br><span class="line">    <span class="built_in">print</span>((der(prei(v1.begin()))))</span><br></pre></td></tr></table></figure></p>
<h3 id="七、Python扩展对象类型"><a href="#七、Python扩展对象类型" class="headerlink" title="七、Python扩展对象类型"></a>七、Python扩展对象类型</h3><p>Python对象类型主要分为三类：</p>
<ul>
<li>内建类型（built-in type）：即Python自带的int、set、dict、list、tuple、str等对象类型</li>
<li>扩展类型（extension type）：用C/C++建立的对象类型</li>
<li>用户自定义类型：使用class关键字在Python中定义的对象类型</li>
</ul>
<p>其中扩展类型时基于Python的C/C++扩展规范。在<code>Python.h</code>中，Python提供了许多C API接口，程序猿利用这些接口实现Python的C/C++类型扩展。实际上，内建类型也是基于此，区别在于已经被Python官方搞定并预置进去罢了。</p>
<h4 id="7-1-PyObject和PyTypeObject"><a href="#7-1-PyObject和PyTypeObject" class="headerlink" title="7.1 PyObject和PyTypeObject"></a>7.1 PyObject和PyTypeObject</h4><p>这两个C结构体是Python中最为关键而基础的结构体。定义在<code>include/object.h</code>（<code>Python.h</code>会include这个文件）中。</p>
<p>PyTypeObject是一个保存Python类型信息的一个C结构体，不同的Python对象（对应PyObject结构体）有着不同的PyTypeObject对象。</p>
<p>PyObject是Python对象对应的结构体，它本身定义了几个基本属性。具体Python类是由不同的结构体实现，再强制转换为PyObject。如Python内置的int对象对应PyIntObject结构体，上述Torch的Tensorbase对象对应THPVariable结构体。其中<strong>这些结构体都“继承”了PyObject</strong>。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_typeobject</span> &#123;</span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *tp_name; <span class="comment">/* For printing, in format &quot;&lt;module&gt;.&lt;name&gt;&quot; （类型的字符串名） */</span></span><br><span class="line">    Py_ssize_t tp_basicsize, tp_itemsize;</span><br><span class="line">    Py_ssize_t tp_maxalloc;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_typeobject</span> *tp_prev;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_typeobject</span> *tp_next;</span><br><span class="line">&#125; PyTypeObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_object</span> &#123;</span><br><span class="line">    Py_ssize_t ob_refcnt;<span class="comment">/* 引用计数器 */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_typeobject</span> *ob_type;<span class="comment">/* 对象类型 */</span></span><br><span class="line">&#125; PyObject;<span class="comment">/* 定义PyObject类型 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用PyObject_HEAD宏形式，故这个宏是所有扩展结构体的首位（下文所述“继承”的要求）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_object</span> &#123;</span><br><span class="line">    PyObject_HEAD          </span><br><span class="line">&#125; PyObject;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是PyObject_HEAD的完整宏定义，其中第一个内容是一个关于debug的宏，可以不用考虑。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyObject_HEAD                   \</span></span><br><span class="line"><span class="meta">    _PyObject_HEAD_EXTRA                \</span></span><br><span class="line"><span class="meta">    Py_ssize_t ob_refcnt;               \</span></span><br><span class="line"><span class="meta">    struct _typeobject *ob_type;  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这是另一个定义版本，也就是先有PyObject_HEAD还是先有PyObject的区别</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyObject_HEAD PyObject ob_base;    </span></span><br></pre></td></tr></table></figure><br>虽然有了Cython，不直接去用Python的C-API进行扩展，但是在Cython中，深刻理解这两个结构体，有助于我们寻到Python对象背后的C/C++类型，如下文中使用Numpy、Torch和获取Python对象内部结构。</p>
<p><img src="https://pic2.zhimg.com/80/v2-80e95e62b6f65d3ca8c752d9d730e5b1_720w.jpg" alt="Python类型与C类型"></p>
<p>C语言结构体不面向对象，不支持直接继承，但可以通过如下形式进行代替。<strong>本质上是因为结构体是紧密相连的数据结构，通过这种形式进行强制转换</strong>（结构体内存不一定连续，但顺序固定，内存占据固定）。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">structA</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">bool</span> flag;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">structB</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">structA</span> sa; <span class="comment">//继承structA，必须放在第一位，等价于把a的两个变量放到这里，这样才能模拟继承（强制转换切割所要求）</span></span><br><span class="line">    std::string name;</span><br><span class="line">    std::string id;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    structB b = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="string">&quot;zhn&quot;</span>, <span class="string">&quot;22060229&quot;</span>&#125;;</span><br><span class="line">    structA * a = (structA *) &amp;b;<span class="comment">//强制转换，不支持面向对象的多态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>所以Python中几个结构体就是就是这么个体现，而object类也就是所有类的父类。<br><img src="https://pic4.zhimg.com/80/v2-bd508541a0ea0d8f37acdca58d5eb17b_720w.jpg" alt="结构体继承"></p>
<p><img src="https://pic4.zhimg.com/80/v2-bf09e863aa021c5bf55baeba94ecbcbb_720w.jpg" alt="结构体继承"></p>
<h4 id="7-2-利用Cython自定义Python扩展类型"><a href="#7-2-利用Cython自定义Python扩展类型" class="headerlink" title="7.2 利用Cython自定义Python扩展类型"></a>7.2 利用Cython自定义Python扩展类型</h4><p>Cython可以避免Python C API的繁琐，通过<code>cdef class</code>进行Python扩展类型的构建。前述创建的C++对象只能在Cython中使用，和其他cdef变量一样无法在python中调用。可以将其作为成员放置于cdef声明的Python类中。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 定义一个能够被Python解释器调用的类来使用C++类</span></span><br><span class="line">cdef <span class="keyword">class</span> <span class="title class_">PyPerson</span>:</span><br><span class="line">    cdef Person cperson <span class="comment">## 输入实例成员变量</span></span><br><span class="line">    cdef <span class="built_in">object</span> encoding <span class="comment">## z如果是写成encoding这种python可访问对象，属性值无法直接修改，因为python不支持修改内建或扩展类属性值</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__cinit__</span>(<span class="params">self, name, <span class="built_in">id</span>, encoding = <span class="string">&quot;utf-8&quot;</span></span>):</span><br><span class="line">        self.encoding = encoding</span><br><span class="line">        self.cperson = Person(string(<span class="built_in">bytes</span>(name, self.encoding)), string(<span class="built_in">bytes</span>(<span class="built_in">id</span>, self.encoding)))</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getName</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> &lt;<span class="built_in">object</span>&gt;(<span class="built_in">str</span>(self.cperson.getName().c_str(), self.encoding))</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getId</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> &lt;<span class="built_in">object</span>&gt;(<span class="built_in">str</span>(self.cperson.getId().c_str(), self.encoding))</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setName</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.cperson.setName(string(<span class="built_in">bytes</span>(name, self.encoding)))</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setId</span>(<span class="params">self, <span class="built_in">id</span></span>):</span><br><span class="line">        self.cperson.setId(string(<span class="built_in">bytes</span>(<span class="built_in">id</span>, self.encoding)))</span><br></pre></td></tr></table></figure></p>
<h4 id="7-3-获取Python对象内部C-C-数据结构"><a href="#7-3-获取Python对象内部C-C-数据结构" class="headerlink" title="7.3 获取Python对象内部C/C++数据结构"></a>7.3 获取Python对象内部C/C++数据结构</h4><p>如前所述，C/C++数据结构被按照Python Extension规范封装成了Python对象，其中未暴露给Python程序的内部C/C++结构是被Python程序无法访问（不是无法被Python解释器访问）。</p>
<p>下例中声明了Numpy的PyArray_Descr（下文讲到它用typedef定义的，故对应使用ctypedef。对应的，其封装类numpy.dtype也用ctypedef声明。<a target="_blank" rel="noopener" href="https://cython.readthedocs.io/en/latest/src/userguide/extension_types.html?highlight=inherit#subclassing">详见相关文档</a>。</p>
<p>我们只需要声明我们想要的内部数据，因为同前面一样，完整的扩展类型声明在对应头文件中已有，cython不需要解析头文件而交给C/C++编译器。因此这个方法只适用于获取内部数据结构，而不适用于建立新的扩展类型，因为还是需要自己去写Python C API实现。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">cdef extern <span class="keyword">from</span> <span class="string">&quot;numpy/arrayobject.h&quot;</span>:</span><br><span class="line">    ...</span><br><span class="line">    ctypedef struct PyArray_Descr:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    ctypedef <span class="keyword">class</span> <span class="title class_">numpy</span>.dtype [<span class="built_in">object</span> PyArray_Descr, check_size ignore]:</span><br><span class="line">        cdef PyTypeObject* typeobj</span><br><span class="line">        cdef char kind</span><br><span class="line">        cdef char <span class="built_in">type</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">cdef extern <span class="keyword">from</span> <span class="string">&quot;complexobject.h&quot;</span>:</span><br><span class="line">    struct Py_complex:</span><br><span class="line">        double real</span><br><span class="line">        double imag</span><br><span class="line"></span><br><span class="line">    <span class="comment">## PyComplexObject为PyObject的“子”结构体，代表复数，__builtin__.complex代表了内建的python类complex</span></span><br><span class="line">    ctypedef <span class="keyword">class</span> <span class="title class_">__builtin__</span>.<span class="built_in">complex</span> [<span class="built_in">object</span> PyComplexObject]:</span><br><span class="line">        cdef Py_complex cval <span class="comment">## 所需获取的数据类型被声明。</span></span><br><span class="line"></span><br><span class="line">//这是complexobject.h中，上述结构体的定义</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    Py_complex cval;</span><br><span class="line">&#125; PyComplexObject;</span><br></pre></td></tr></table></figure></p>
<h3 id="七、Cython预定义的C-C-标准库"><a href="#七、Cython预定义的C-C-标准库" class="headerlink" title="七、Cython预定义的C/C++标准库"></a>七、Cython预定义的C/C++标准库</h3><p>为了方便起见，常见的C/C++的标准库被预定义在<code>libc</code>和<code>libcpp</code>两个库中。库中文件是pxd文件（前述类似于头文件），pxd文件内容其实就是前面vector自定义一样的内容。内容详见<a target="_blank" rel="noopener" href="https://github.com/cython/cython/tree/master/Cython/Includes">Cython的github主页</a></p>
<p>如前所见，pxd库通过cimport语句导入。</p>
<p>标准库类型与Python对象的自动转化<br><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Python type =&gt;	C++ type	=&gt; Python type</span><br><span class="line">bytes	std::string	bytes</span><br><span class="line">iterable	std::vector	list</span><br><span class="line">iterable	std::list	list</span><br><span class="line">iterable	std::set	set</span><br><span class="line">iterable (len 2)	std::pair	tuple (len 2)</span><br></pre></td></tr></table></figure><br>因此支持：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector[<span class="built_in">int</span>] v = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>]</span><br><span class="line">string m = <span class="string">&quot;hello&quot;</span> <span class="comment">## 转换为char * 后调用复制构造函数 </span></span><br><span class="line">string m = <span class="string">b&quot;hello&quot;</span> <span class="comment">## 前述转化支持</span></span><br></pre></td></tr></table></figure></p>
<h3 id="八、用Cython扩展使用Numpy"><a href="#八、用Cython扩展使用Numpy" class="headerlink" title="八、用Cython扩展使用Numpy"></a>八、用Cython扩展使用Numpy</h3><p>Numpy是Python中数据科学运算的基础库，属于用C语言编写的Python扩展库。虽然Numpy本身提供了许多用C实现的方法，但是有些时候还是不得不用Python进行慢操作，如使用Python循环处理一些numpy不支持的转换。当数据量大时，也就丧失了Numpy作为C扩展库的优势。因此，可以通过Cython来加速这个过程，这等效于给numpy提供了新的C扩展方法。Cython中内置了numpy的定义库（在%CYTHON<em>HOME%\Includes\numpy_<em>init</em></em>.pxd中）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">%%cython</span><br><span class="line">cimport numpy <span class="keyword">as</span> np <span class="comment">## Cython内置了numpy定义的引入</span></span><br><span class="line">cpdef cSum(np.ndarray array): <span class="comment">## numpy数组对应的C类型为ndarray类（结构体）</span></span><br><span class="line">    <span class="comment">## numpy数据类型多样，但统一使用char *指针保存，使用时根据datatype进行强制转换, 务必根据自身的dtype进行转化</span></span><br><span class="line">    cdef np.npy_int64 * data = &lt;np.npy_int64 *&gt; array.data  </span><br><span class="line">    cdef <span class="built_in">int</span> i</span><br><span class="line">    cdef <span class="built_in">int</span> <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(array.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="comment">#若使用int指针，为32位4字节的数组，int64对应的64位8字节长度的npy_int64, 这时候取值就得间隔一位取值了即data[2*i]</span></span><br><span class="line">        <span class="built_in">sum</span> += data[i] </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pSum</span>(<span class="params">array</span>):</span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(array.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="built_in">sum</span> += array[i]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span></span><br></pre></td></tr></table></figure><br>上述Cython代码定义了基于C的求和方法cSum和基于python的求和方法pSum，由下面Python测试结果可知，c实现的运算速率显著高于Python。当然numpy自身提供了求和，这里只是作为示例。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">v = np.random.randint(<span class="number">0</span>, <span class="number">100</span>,size=[<span class="number">1000000</span>])</span><br><span class="line"></span><br><span class="line">%timeit cSum(v)</span><br><span class="line">OUT[<span class="number">1</span>]: <span class="number">493</span> µs ± <span class="number">2.3</span> µs per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">1000</span> loops each)</span><br><span class="line"></span><br><span class="line">%timeit pSum(v)</span><br><span class="line">OUT[<span class="number">2</span>]: <span class="number">190</span> ms ± <span class="number">26</span> ms per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">1</span> loop each)</span><br><span class="line"></span><br><span class="line">%timeit v.<span class="built_in">sum</span>()  <span class="comment">## 用numpy自身sum做比较</span></span><br><span class="line">OUT[<span class="number">3</span>]: <span class="number">504</span> µs ± <span class="number">1.76</span> µs per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">1000</span> loops each)</span><br></pre></td></tr></table></figure><br>Numpy的dtype由一个C结构体PyArray_Descr保存，其中类型信息保存在结构体PyTypeObject中，这是Python中保存数据结构信息的一个结构体，下文会有<a href="#93-pyobject和pytypeobject">更加详细的介绍</a>。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    PyTypeObject *typeobj;</span><br><span class="line">    <span class="type">char</span> kind;</span><br><span class="line">    <span class="type">char</span> type;</span><br><span class="line">    <span class="type">char</span> byteorder;</span><br><span class="line">    <span class="type">char</span> flags;</span><br><span class="line">    <span class="type">int</span> type_num;</span><br><span class="line">    <span class="type">int</span> elsize;</span><br><span class="line">    <span class="type">int</span> alignment;</span><br><span class="line">    PyArray_ArrayDescr *subarray;</span><br><span class="line">    PyObject *fields;</span><br><span class="line">    PyObject *names;</span><br><span class="line">    PyArray_ArrFuncs *f;</span><br><span class="line">    PyObject *metadata;</span><br><span class="line">    NpyAuxData *c_metadata;</span><br><span class="line">    <span class="type">npy_hash_t</span> hash;</span><br><span class="line">&#125; PyArray_Descr;</span><br></pre></td></tr></table></figure></p>
<h3 id="九、用Cython扩展使用Torch"><a href="#九、用Cython扩展使用Torch" class="headerlink" title="九、用Cython扩展使用Torch"></a>九、用Cython扩展使用Torch</h3><h4 id="9-1-Torch的配置"><a href="#9-1-Torch的配置" class="headerlink" title="9.1 Torch的配置"></a>9.1 Torch的配置</h4><p>Cython可以使用C++的Torch库扩展LibTorch，其在pytorch中附带，也可以去pytorch.org下载libtorch。使用前，需要在setup文件中配置头文件目录、库文件目录和库文件。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Extension(<span class="string">&quot;*&quot;</span>, [<span class="string">&quot;../src/Tensor.pyx&quot;</span>],</span><br><span class="line">    include_dirs=[</span><br><span class="line">        torch.get_file_path()+<span class="string">&quot;\\torch\\include&quot;</span>,</span><br><span class="line">        torch.get_file_path()+<span class="string">&quot;\\torch\\include\\torch\\csrc\\api\\include&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    library_dirs=[</span><br><span class="line">        torch.get_file_path()+<span class="string">&quot;\\torch\\lib&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    libraries=[</span><br><span class="line">        <span class="string">&quot;mkldnn&quot;</span>,</span><br><span class="line">        <span class="string">&quot;shm&quot;</span>,</span><br><span class="line">        <span class="string">&quot;torch&quot;</span>,</span><br><span class="line">        <span class="string">&quot;torch_cpu&quot;</span>,</span><br><span class="line">        <span class="string">&quot;torch_cuda&quot;</span>,</span><br><span class="line">        <span class="string">&quot;torch_python&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_C&quot;</span>,</span><br><span class="line">        <span class="string">&quot;asmjit&quot;</span>,</span><br><span class="line">        <span class="string">&quot;c10&quot;</span>,</span><br><span class="line">        <span class="string">&quot;c10_cuda&quot;</span>,</span><br><span class="line">        <span class="string">&quot;caffe2_detectron_ops_gpu&quot;</span>,</span><br><span class="line">        <span class="string">&quot;caffe2_module_test_dynamic&quot;</span>,</span><br><span class="line">        <span class="string">&quot;caffe2_nvrtc&quot;</span>,</span><br><span class="line">        <span class="string">&quot;caffe2_observers&quot;</span>,</span><br><span class="line">        <span class="string">&quot;clog&quot;</span>,</span><br><span class="line">        <span class="string">&quot;cpuinfo&quot;</span>,</span><br><span class="line">        <span class="string">&quot;dnnl&quot;</span>,</span><br><span class="line">        <span class="string">&quot;fbgemm&quot;</span>,</span><br><span class="line">        <span class="string">&quot;libprotobuf&quot;</span>,</span><br><span class="line">        <span class="string">&quot;libprotobuf-lite&quot;</span>,</span><br><span class="line">        <span class="string">&quot;libprotoc&quot;</span></span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>在Cython中声明或间接使用的LibTorch库中的方法，需要将其DLL文件拷贝至pyd文件目录下，让python找到并装载。但是请注意，此时不能再在python中<code>import torch</code>，因为会重复装载DLL而产生如下报错：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImportError: Key already registered with the same priority</span><br></pre></td></tr></table></figure><br>此时建议不要拷贝DLL，直接先<code>import torch</code>，装载的DLL在python中时共享的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> dist.Tensor <span class="comment">## 这是一个自定义的torch C++处理，由Cython打包</span></span><br></pre></td></tr></table></figure></p>
<h4 id="9-2-Python类型Tensor转为C-类型"><a href="#9-2-Python类型Tensor转为C-类型" class="headerlink" title="9.2 Python类型Tensor转为C++类型"></a>9.2 Python类型Tensor转为C++类型</h4><p>在Python中使用的<code>torch.Tensor</code>类是C++类<code>torch::autograd::Variable</code>的一个为满足Python扩展类型要求规范的一个封装。其定义在<code>torch/tensor.py</code>文件下。从其定义可以看到其继承自<code>torch._C._TensorBase</code>类，这是C/C++扩展类，位于<code>_C.cp38-win_amd64.pyd</code>中。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//这是一个没有显式__init__方法的类，因此创建实例是通过torch.tensor方法实现的。</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tensor</span>(torch._C._TensorBase):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__deepcopy__</span>(<span class="params">self, memo</span>):</span><br><span class="line">        ....</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce_ex__</span>(<span class="params">self, proto</span>):</span><br><span class="line">        ....</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setstate__</span>(<span class="params">self, state</span>):</span><br><span class="line">        ....</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self, gradient=<span class="literal">None</span>, retain_graph=<span class="literal">None</span>, create_graph=<span class="literal">False</span></span>):</span><br><span class="line">        torch.autograd.backward(self, gradient, retain_graph, create_graph)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">register_hook</span>(<span class="params">self, hook</span>):</span><br><span class="line">        ....</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reinforce</span>(<span class="params">self, reward</span>):</span><br><span class="line">        ....</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><br>而通过阅读pytorch源码<code>torch/csrc/autograd/python_variable.cpp</code>，其python扩展定义如下。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义了THPVariable的初始化方法（对应python的__new__()），返回统一转为PyObject *指针</span></span><br><span class="line"><span class="function"><span class="type">static</span> PyObject *<span class="title">THPVariable_pynew</span><span class="params">(PyTypeObject *type, PyObject *args, PyObject *kwargs)</span> </span>&#123;</span><br><span class="line">    HANDLE_TH_ERRORS</span><br><span class="line">    jit::tracer::<span class="built_in">warn</span>(<span class="string">&quot;torch.Tensor&quot;</span>, jit::tracer::WARN_CONSTRUCTOR);</span><br><span class="line">    <span class="keyword">auto</span> tensor = torch::utils::<span class="built_in">legacy_tensor_ctor</span>(torch::tensors::<span class="built_in">get_default_dispatch_key</span>(), torch::tensors::<span class="built_in">get_default_scalar_type</span>(), args, kwargs);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">THPVariable_NewWithVar</span>(type, std::<span class="built_in">move</span>(tensor));</span><br><span class="line">    END_HANDLE_TH_ERRORS</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Python扩展类型信息定义</span></span><br><span class="line">PyTypeObject THPVariableType = &#123;</span><br><span class="line">    <span class="built_in">PyVarObject_HEAD_INIT</span>(<span class="literal">nullptr</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;torch._C._TensorBase&quot;</span>,                      <span class="comment">/* 类型名称 */</span></span><br><span class="line">    <span class="built_in">sizeof</span>(THPVariable),                         <span class="comment">/* tp_basicsize */</span></span><br><span class="line">    <span class="number">0</span>,                                           <span class="comment">/* tp_itemsize */</span></span><br><span class="line">    (destructor)THPVariable_dealloc,             <span class="comment">/* tp_dealloc */</span></span><br><span class="line">    <span class="number">0</span>,                                           <span class="comment">/* tp_vectorcall_offset */</span></span><br><span class="line">    <span class="literal">nullptr</span>,                                     <span class="comment">/* tp_getattr */</span></span><br><span class="line">    <span class="literal">nullptr</span>,                                     <span class="comment">/* tp_setattr */</span></span><br><span class="line">    ...</span><br><span class="line">    THPVariable_pynew                            <span class="comment">/* 初始化方法的函数指针 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Python C-API注册类型</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">THPVariable_initModule</span><span class="params">(PyObject *<span class="keyword">module</span>)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">PyModule_AddObject</span>(<span class="keyword">module</span>, <span class="string">&quot;_TensorBase&quot;</span>,   (PyObject *)&amp;THPVariableType);</span><br><span class="line">    torch::autograd::<span class="built_in">initTorchFunctions</span>(<span class="keyword">module</span>);</span><br><span class="line">    torch::autograd::<span class="built_in">initTensorImplConversion</span>(<span class="keyword">module</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>也就是说其类型定义就是<code>THPVariableType</code>这个<code>PyTypeObject</code>类实例，其中具体内部C++类型是<code>THPVariable</code>，它是声明在<code>torch/csrc/autograd/python_variable.h</code>中的一个结构体。在头文件中还提供了一个将<code>PyObject *</code>（对应python的object）转换为C++数据类型的方法。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构体，对应前述的torch._C._TensorBase</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">THPVariable</span> &#123;</span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    torch::autograd::Variable cdata; <span class="comment">//这其实就是内部C++类型</span></span><br><span class="line">    PyObject* backward_hooks = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回C++类型，在</span></span><br><span class="line"><span class="keyword">inline</span> torch::<span class="function">autograd::Variable&amp; <span class="title">THPVariable_Unpack</span><span class="params">(PyObject* obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> var = (THPVariable*)obj;</span><br><span class="line">    <span class="keyword">return</span> var-&gt;cdata;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>而在C++文件<code>torch/csrc/autograd/function_hook.h</code>中，我们可以看到<code>torch::autograd::Variable</code>其实就是<code>at::Tensor</code>。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> torch &#123; </span><br><span class="line">    <span class="keyword">namespace</span> autograd &#123;</span><br><span class="line">        <span class="keyword">using</span> Variable = at::Tensor;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1] <a target="_blank" rel="noopener" href="https://numpy.org/doc/stable/reference/c-api/">Numpy C API在线文档</a></p>
<p>[2] <a target="_blank" rel="noopener" href="https://cython.readthedocs.io/en/latest/">Cython官方文档</a></p>
<p>[3] <a target="_blank" rel="noopener" href="https://pytorch.org/cppdocs/">Pytorch C++ API在线文档</a></p>
<p>[4] <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/extending/newtypes_tutorial.html">自定义扩展类型：教程</a></p>
<p>[5] <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/165232299">知乎-对Python内核的理解</a></p>
<p>[6] <a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhchoutai/p/8337653.html">博客园-PyObject对象机制的基石</a></p>
</div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-meta">本文作者: </span><span class="post-copyright-info"><a href="mailto:undefined">GCS-ZHN</a></span></div><div class="post-copyright-type"><span class="post-copyright-meta">本文链接: </span><span class="post-copyright-info"><a href="https://gcszhn.top/2021/03/15/cython/">https://gcszhn.top/2021/03/15/cython/</a></span></div><div class="post-copyright-notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://gcszhn.top">潇洒记忆</a>！</span></div></div></article><div id="pagination"><div class="prev-post pull-left"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/2021/05/13/cpp/"><i class="fas fa-angle-left">&nbsp;</i><span>C++学习笔记</span></a></div></div><!--div!= paginator()--></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-file-o"></i></span><span id="busuanzi_value_page_pv"></span><span></span></div><div class="copyright">&copy;2017 ～ 2022 By GCS-ZHN</div><a href="https://beian.miit.gov.cn/" target="_blank">&nbsp; 浙ICP备2022014039号</a></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--></body></html>