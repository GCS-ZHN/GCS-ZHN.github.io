<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="C++学习笔记"><meta name="keywords" content="C++,cpp"><meta name="author" content="GCS-ZHN,undefined"><meta name="copyright" content="GCS-ZHN"><title>C++学习笔记【潇洒记忆】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><link rel="icon" href="/favicon.ico"><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- script(src=url_for("/js/mathjax/mathjax.js"))--><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  gitment: {},
  valine: {},
}</script><meta name="generator" content="Hexo 6.0.0"></head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="toggle-sidebar-info button-hover"><span data-toggle="文章目录">站点概览</span></div><div class="sidebar-toc"><div class="sidebar-toc-title">目录</div><div class="sidebar-toc-progress"><span class="progress-notice">您已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc-progress-bar"></div></div><div class="sidebar-toc-content" id="sidebar-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81Dev-C-C-%E7%BC%96%E8%AF%91%E5%99%A8gcc-g"><span class="toc-number">1.</span> <span class="toc-text">一、Dev C&#x2F;C++编译器gcc&#x2F;g++</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%B8%B8%E8%A7%81%E7%BC%96%E8%AF%91%E5%8F%82%E6%95%B0%E4%B8%8E%E7%9B%B8%E5%85%B3%E6%96%87%E4%BB%B6"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 常见编译参数与相关文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 编译过程概述</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81-cl%E7%BC%96%E8%AF%91%E5%99%A8%EF%BC%8CVisual-C"><span class="toc-number">2.</span> <span class="toc-text">二、 cl编译器，Visual C++</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E7%9B%B8%E5%85%B3%E6%96%87%E4%BB%B6"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 相关文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%8F%82%E6%95%B0"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-declspec-dllimport-%E5%92%8C-declspec-dllexport"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 _declspec(dllimport)和_declspec(dllexport)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%85%B1%E4%BA%AB%E5%BA%93%E7%94%9F%E6%88%90%E4%B8%8E%E9%93%BE%E6%8E%A5"><span class="toc-number">3.</span> <span class="toc-text">三、共享库生成与链接</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E9%9D%99%E6%80%81%E5%85%B1%E4%BA%AB%E5%BA%93%E7%94%9F%E6%88%90"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 静态共享库生成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E5%8A%A8%E6%80%81%E5%85%B1%E4%BA%AB%E5%BA%93%E7%94%9F%E6%88%90"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 动态共享库生成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E5%85%B1%E4%BA%AB%E5%BA%93%E7%9A%84%E9%93%BE%E6%8E%A5"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 共享库的链接</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Editplus%E5%91%BD%E4%BB%A4%E9%85%8D%E7%BD%AE"><span class="toc-number">4.</span> <span class="toc-text">四、Editplus命令配置</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81C-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">5.</span> <span class="toc-text">五、C++对象创建的两种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-C-%E7%BC%96%E8%AF%91%E5%99%A8%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 C++编译器内存区域划分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E5%A3%B0%E6%98%8E%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 声明对象与对象数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-new%E5%85%B3%E9%94%AE%E5%AD%97%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 new关键字创建对象</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%8C%87%E9%92%88"><span class="toc-number">6.</span> <span class="toc-text">六、指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%8C%87%E9%92%88%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">6.1.</span> <span class="toc-text">1. 指针的本质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E3%80%81%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE%E4%B8%8E%E6%8C%87%E9%92%88%E6%82%AC%E6%91%86"><span class="toc-number">6.2.</span> <span class="toc-text">2. 内存泄露、内存释放与指针悬摆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E4%B8%8E%E5%B8%B8%E9%87%8F%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">6.3.</span> <span class="toc-text">3. 常量指针与常量成员函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%AF%B9%E8%B1%A1%E9%87%8D%E8%BD%BD%E6%9E%84%E9%80%A0%E5%99%A8%E5%85%B1%E4%BA%AB%E4%BB%A3%E7%A0%81"><span class="toc-number">7.</span> <span class="toc-text">七、对象重载构造器共享代码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-placement-new%E7%AD%96%E7%95%A5"><span class="toc-number">7.1.</span> <span class="toc-text">1.placement new策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%80%9A%E8%BF%87%E5%87%BD%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-number">7.2.</span> <span class="toc-text">2.通过函数默认值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%85%B1%E4%BA%AB"><span class="toc-number">7.3.</span> <span class="toc-text">3.成员函数共享</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">7.4.</span> <span class="toc-text">4.委托构造函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E9%AB%98%E7%BA%A7%E5%87%BD%E6%95%B0"><span class="toc-number">8.</span> <span class="toc-text">八、高级函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">8.1.</span> <span class="toc-text">1. 复制构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">8.2.</span> <span class="toc-text">2.移动构造函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-2-1-%E5%B7%A6%E5%80%BC%E4%B8%8E%E5%8F%B3%E5%80%BC"><span class="toc-number">9.</span> <span class="toc-text">8.2.1 左值与右值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-2-2-%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">10.</span> <span class="toc-text">8.2.2 左值引用与右值引用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-2-3-%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">11.</span> <span class="toc-text">8.2.3 移动构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">11.1.</span> <span class="toc-text">3.编译阶段常量表达式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">12.</span> <span class="toc-text">九、运算符与运算符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%87%AA%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">12.1.</span> <span class="toc-text">1. 自增运算符++</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">12.2.</span> <span class="toc-text">2. 加法运算符+</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">12.3.</span> <span class="toc-text">3. 赋值运算符&#x3D;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97"><span class="toc-number">12.4.</span> <span class="toc-text">4. 转换运算</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81"><span class="toc-number">13.</span> <span class="toc-text">十、类的继承与多态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%BB%A7%E6%89%BF"><span class="toc-number">13.1.</span> <span class="toc-text">1. 继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">13.2.</span> <span class="toc-text">2. 权限修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%BB%A7%E6%89%BF%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E4%B8%8E%E9%94%80%E6%AF%81"><span class="toc-number">13.3.</span> <span class="toc-text">3. 继承类的构造与销毁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%87%BD%E6%95%B0%E8%A6%86%E7%9B%96%EF%BC%88%E9%87%8D%E5%86%99%EF%BC%89%E4%B8%8E%E5%A4%9A%E6%80%81"><span class="toc-number">13.4.</span> <span class="toc-text">4. 函数覆盖（重写）与多态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">13.5.</span> <span class="toc-text">5. 抽象类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81C-%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BA%A4%E4%BA%92"><span class="toc-number">14.</span> <span class="toc-text">十一、C++与系统的交互</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E7%9A%84%E8%8E%B7%E5%8F%96"><span class="toc-number">14.1.</span> <span class="toc-text">1. 命令行参数的获取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%95%E7%9A%84%E6%9A%82%E5%81%9C"><span class="toc-number">14.2.</span> <span class="toc-text">2. 程序执行完毕的暂停</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81C-%E7%9A%84IO%E6%93%8D%E4%BD%9C"><span class="toc-number">15.</span> <span class="toc-text">十二、C++的IO操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-C-%E7%9A%84IO%E6%96%B9%E6%B3%95%E7%B1%BB%E5%BA%93%E4%BD%93%E7%B3%BB"><span class="toc-number">15.1.</span> <span class="toc-text">1. C++的IO方法类库体系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%96%87%E4%BB%B6%E6%B5%81fstream"><span class="toc-number">15.2.</span> <span class="toc-text">2.文件流fstream</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%89%E3%80%81%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E4%B8%8ELambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">16.</span> <span class="toc-text">十三、函数指针与Lambda表达式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E5%9B%9B%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B"><span class="toc-number">17.</span> <span class="toc-text">十四、线程与进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#14-1-pthread"><span class="toc-number">17.1.</span> <span class="toc-text">14.1 pthread</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="toc-number">18.</span> <span class="toc-text">参考文献</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/avatar.png"></div><div class="author-info-name">GCS-ZHN</div><div class="author-info-description"></div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/GCS-ZHN" target="_blank">GitHub<i class="icon-dot bg-color3"></i></a><a class="links-button button-hover" href="mailto:zhang.h.n@foxmail.com" target="_blank">E-Mail<i class="icon-dot bg-color6"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/archives"><span class="pull-top">日志</span><span class="pull-bottom">26</span></a><a class="author-info-articles-tags article-meta" href="/tags"><span class="pull-top">标签</span><span class="pull-bottom">55</span></a><a class="author-info-articles-categories article-meta" href="/categories"><span class="pull-top">分类</span><span class="pull-bottom">18</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/archives">归档</a></nav><div class="right-info"><a class="title-name" href="/">潇洒记忆</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="title">C++学习笔记</div><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 发表于 2021-05-13 | 更新于 2024-10-24</time><!--time.button-hover.post-date #[i.fas.fa-calendar-alt.article-icon(aria-hidden="true")] #[=__('post.modified')] #[=date(page['updated'], config.date_format)]--><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/C/">C++</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/cpp/">cpp</a></div></div></div><div class="main-content"><h1 id="一、Dev-C-C-编译器gcc-g"><a href="#一、Dev-C-C-编译器gcc-g" class="headerlink" title="一、Dev C/C++编译器gcc/g++"></a>一、Dev C/C++编译器gcc/g++</h1><h2 id="1-1-常见编译参数与相关文件"><a href="#1-1-常见编译参数与相关文件" class="headerlink" title="1.1 常见编译参数与相关文件"></a>1.1 常见编译参数与相关文件</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">参数名</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-c</td>
<td style="text-align:left">仅编译，不链接</td>
</tr>
<tr>
<td style="text-align:left">-o</td>
<td style="text-align:left">输出文件名</td>
</tr>
<tr>
<td style="text-align:left">-l</td>
<td style="text-align:left">链接库文件名，动态库（.so(linux)/.dll(win))、静态库（.a），仅用于链接时寻找库，而可执行文件寻找动态库仍然依据系统环境变量。</td>
</tr>
<tr>
<td style="text-align:left">-L</td>
<td style="text-align:left">链接库所在路径文件夹</td>
</tr>
<tr>
<td style="text-align:left">-I</td>
<td style="text-align:left">头文件所在文件夹</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
</div>
<p>.dll|动态库（dynamic linked library）文件<br>.h/.hpp|头文件，由于预编译时被“#include”指令包含</p>
<h2 id="1-2-编译过程概述"><a href="#1-2-编译过程概述" class="headerlink" title="1.2 编译过程概述"></a>1.2 编译过程概述</h2>
	<img src="/2021/05/13/cpp/compiler_process.png" class="" title="编译过程">

<p>1.预编译器执行#include、#define等编译指令对源文件进行预处理，include指令的作用等同于jsp:include，即文本替换包含进源文件。</p>
<p>如果一个文件中包含许多头文件，编译器为了优化编译速度，会预编译头文件为.h.gch文件，下次将会加载.h.gch文件。当修改.h文件时需要删除.h.gch文件。<br><span id="more"></span><br>2.编译器将源文件（.cpp/.c）编译为中间文件（.o）;</p>
<p><code>gcc/g++ -c source.cpp/.c</code></p>
<p>3.编译器将多个.o文件链接为生成可执行文件，window下是exe;</p>
<p><code>gcc/g++ tmp1.o tmp2.o -o target.exe</code></p>
<p>4.若没有链接其他源文件，即没有使用其他文件中的定义，可以直接一步到位;</p>
<p><code>gcc/g++ source.cpp -o target.exe</code></p>
<p>5.在链接的多个中间文件（.o）中，不能对函数进行重复定义，故而一般不会在共享头文件中定义函数，而只是声明函数原型，因为头文件包含不同于java的import，是文本替换;</p>
<p>6.链接过程分为静态链接和动态链接;</p>
<p>(1)<strong>静态链接</strong>: 即把链接的东西包含在生成的可执行文件中，删除链接后的静态链接库，如.a，不会影响可执行文件运行，但体积相对较大，不过运行相对较快.</p>
<p>(2)<strong>动态链接</strong>: 是在执行的过程中再去寻找动态链接库，如<code>.so/.dll</code>，若缺失动态链接库，会报错，但可执行文件较小，但运行相对较慢，动态链接库更类似于java的类库使用，多个文件共享动态库时只是获得了一个函数的相同引用，而静态库是将函数一份份拷贝，因此除了持久化储存空间占用多，运行内存占用也多但如果头文件不在一个项目中多个源文件中使用，可以定义函数在头文件中。声明是可以多个链接文件相互重复的，定义一般不行。</p>
<p>7.还可以将多个源文件（.cpp/.c）一起编译成一个可执行文件或.o文件。</p>
<p><code>gcc/g++ source.cpp source1.cpp -o target.exe</code></p>
<p>8.C++编译器允许include后的源文件存在重复的声明，但不允许重复的定义。如声明<code>void hello();void hello;</code>两个hello函数，但不允许<code>class myc &#123;&#125;; class myc &#123;&#125;</code>重复定义两个myc类。</p>
<p>9.链接器生成的可执行文件需要于自定义动态链接库放置于相同目录下，除非修改系统环境变量。当然修改环境变量也可以由exe程序本身实现</p>
<p>10.CPLUS_INCLUDE_PATH环境变量配置第三方Include的头文件目录，也可以用-I参数在g++编译时指定，C_INCLUDE_PATH环境变量则指定gcc编译器的include目录</p>
<p>11.LIBRARY_PATH环境变量配置g++/gcc编译时对应的共享库目录，也可以通过-L参数指定</p>
<h1 id="二、-cl编译器，Visual-C"><a href="#二、-cl编译器，Visual-C" class="headerlink" title="二、 cl编译器，Visual C++"></a>二、 cl编译器，Visual C++</h1><p>微软提供的编译环境，适合Windows开发。</p>
<h2 id="2-1-相关文件"><a href="#2-1-相关文件" class="headerlink" title="2.1 相关文件"></a>2.1 相关文件</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
</div>
<p>.lib|静态库文件，链接时被包含进exe可执行文件，除了作为静态库自身作用，也可以作为动态库DLL的指引（见下文）。<br>g++编译器可以直接通过-l指令指定动态库编译。<br>.dll|动态库（dynamic linked library）文件<br>.pdb|数据库文件，保存一些编译信息，常用于开发时Debug，VS中在调试-&gt;选项-&gt;符号表中设置符号表路径<br>.h/.hpp|头文件，由于预编译时被“#include”指令包含<br>.obj|通用对象文件格式文件，编译与链接的中间二进制文件</p>
<h2 id="2-2-参数"><a href="#2-2-参数" class="headerlink" title="2.2 参数"></a>2.2 参数</h2><p>注意，cl的参数一般使用“/”开头，但不排斥“-”，另外，很多参数可以与值无空格使用，如“\DWWW=10”与“\D WWW=10”都是预定义了WWW这个宏。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">参数名</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">/Tc</td>
<td style="text-align:left">指定C源文件，如/Tp test.c，不使用会根据尾缀判断</td>
</tr>
<tr>
<td style="text-align:left">/Tp</td>
<td style="text-align:left">指定C++源文件，如/Tp test.cpp</td>
</tr>
<tr>
<td style="text-align:left">/EH</td>
<td style="text-align:left">异常处理模式，一般用/EHsc</td>
</tr>
<tr>
<td style="text-align:left">/Fe</td>
<td style="text-align:left">指定输出exe文件名</td>
</tr>
<tr>
<td style="text-align:left">/I</td>
<td style="text-align:left">头文件目录，适用于不在当前目录和INCLUDE变量目录下的头文件</td>
</tr>
<tr>
<td style="text-align:left">/c</td>
<td style="text-align:left">只编译，不链接</td>
</tr>
<tr>
<td style="text-align:left">/Z7</td>
<td style="text-align:left">不产生.pdb/.lib等文件，将所有调试信息存入.obj文件中</td>
</tr>
<tr>
<td style="text-align:left">/ZI</td>
<td style="text-align:left">产生.pdb/.lib等文件，用于调试等需求</td>
</tr>
<tr>
<td style="text-align:left">/C</td>
<td style="text-align:left">编译期间保留注释</td>
</tr>
<tr>
<td style="text-align:left">/sdl</td>
<td style="text-align:left">进行安全检查，这对老式代码不兼容</td>
</tr>
<tr>
<td style="text-align:left">/std</td>
<td style="text-align:left">指定c++版本，可选:<br>/std:c++14<br>/std:c++17<br>/std:c++latest</td>
</tr>
<tr>
<td style="text-align:left">/D</td>
<td style="text-align:left">预定义宏，如/D MAR=10，那么相当于源码中定义了一个宏MAR，值为10。若没有值，默认为0。下例中，若<code>cl /TP test.cpp /EHsc</code>编译，则运行<code>./test</code>输出NO WWW，若<code>cl /TP test.cpp /EHsc /D W=10</code>编译，输出为宏值10</td>
</tr>
<tr>
<td style="text-align:left">/RTC</td>
<td style="text-align:left">进行运行时错误检查，可选：<br>/RTCs<br>/RTC1<br>/RTCc<br>/RTCu</td>
</tr>
<tr>
<td style="text-align:left">/utf-8</td>
<td style="text-align:left">指定为utf-8编码</td>
</tr>
<tr>
<td style="text-align:left">/LD、/LDd</td>
<td style="text-align:left">创建动态库dll，会产生test.DLL和test.obj。配合/ZI会产生对应的test.lib和test.pdb，示例：<br><code>cl /TP test.cpp /EHsc /sdl /std:c++14 /LDd</code></td>
</tr>
<tr>
<td style="text-align:left">/link</td>
<td style="text-align:left">用于指定链接器（link.exe，由cl负责调用）链接的静态链接库（.lib）。对于动态库DLL，无法直接如gcc那样通过参数链接，需要指定对应的静态链接库（只起到指导动态库名称作用）。有以下三种情况：<br>源码开始：<code>cl /TP call.cpp /link test.lib</code><br>中间码开始：<code>cl call.obj /link test.lib</code><br>源码中加入编译指令：<code>#pragma comment(lib, &quot;test.lib&quot;)</code></td>
</tr>
<tr>
<td style="text-align:left">/?</td>
<td style="text-align:left">cl的帮助指令，可以<code>cl /? &gt; file.txt</code>将帮助信息重定向而方便阅读</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*/D预定义宏的示例</span></span><br><span class="line"><span class="comment">cl /Tp test.cpp /EHsc /D WWW=10 ,输出10</span></span><br><span class="line"><span class="comment">cl /Tp test.cpp /EHsc /D WWW, 输出0</span></span><br><span class="line"><span class="comment">cl /Tp test.cpp /EHsc，输出No WWW</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> WWW</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WWW <span class="string">&quot;NO WWW&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">	std::cout &lt;&lt; WWW &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-declspec-dllimport-和-declspec-dllexport"><a href="#2-3-declspec-dllimport-和-declspec-dllexport" class="headerlink" title="2.3 _declspec(dllimport)和_declspec(dllexport)"></a>2.3 _declspec(dllimport)和_declspec(dllexport)</h2><p>对于MSVC的编译器cl，想要使用DLL库，必须指定DLL中哪些成员是导出的（dllexport），哪些成员是从DLL库导入来使用的（dllexport），类似于模块化import/export。同时，由于DLL和EXE的内存分配方式是独立，因此需要注意采用相同的运行时库来统一内存分配，以便在传输C++对象时能够正确释放内存。下例中统一使用了<code>/MD</code>链接了MSVCRT.LIB。cl提供了以下四种指令对应四种运行时库（前三种试验验证可以正确传输object，第四种/MTd失败）。<strong>由于原因不在编译而在于运行，故单独编译DLL和EXE都没有任何ERROR提示</strong>。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Param</th>
<th style="text-align:left">Library</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">/MD</td>
<td style="text-align:left">MSVCRT.LIB</td>
</tr>
<tr>
<td style="text-align:left">/MDd</td>
<td style="text-align:left">MSVCRTD.LIB debug lib</td>
</tr>
<tr>
<td style="text-align:left">/MT</td>
<td style="text-align:left">LIBCMT.LIB</td>
</tr>
<tr>
<td style="text-align:left">/MTd</td>
<td style="text-align:left">LIBCMTD.LIB debug lib</td>
</tr>
</tbody>
</table>
</div>
<p><strong>由于默认编译时DLL和EXE对应的VC运行库不一样，故在C++中推荐使用C数组代替C++ string对象进行DLL与EXE对接。</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DLL库源码，cl /TP library.cpp /EHsc /sdl /std:c++14 /LDd /ZI /MD</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DLL_EXPORT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DLL_EXPORT __declspec(dllexport)</span></span><br><span class="line"><span class="function">DLL_EXPORT <span class="type">void</span> <span class="title">print</span><span class="params">(std::string args)</span></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; args &lt;&lt; std:: endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//DLL库使用头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;library.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DLL_IMPORT __declspec(dllimport)</span></span><br><span class="line"><span class="function">DLL_IMPORT <span class="type">void</span> <span class="title">print</span><span class="params">(std::string)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//外部程序调用， cl /TP call.cpp /EHsc /sdl /std:c++14 /MD</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.hpp&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span>&#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;Test string&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但对于gcc/g++，没有这个限制，因为会默认会导出DLL中所有全局的成员，只需要在编译时声明就好（或include对应头文件）。也没有运行时内存分配问题，估计是编译器做了统一。统一使用-l参数指定链接的动态/静态库，-L参数指定库路径。</p>
<h1 id="三、共享库生成与链接"><a href="#三、共享库生成与链接" class="headerlink" title="三、共享库生成与链接"></a>三、共享库生成与链接</h1>
	<img src="/2021/05/13/cpp/lib_compiler.png" class="" title="共享库生成与链接">

<h2 id="3-1-静态共享库生成"><a href="#3-1-静态共享库生成" class="headerlink" title="3.1 静态共享库生成"></a>3.1 静态共享库生成</h2><p>对于dev-c/c++的gcc/g++，在linux/win下，借用ar命令，$(FileNameNoExt)代指无后缀文件名, 下同，注意静态库需要先将源码编译成.o文件，ar命令只负责打包<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar cr lib$(FileNameNoExt).a $(FileNameNoExt).o</span><br></pre></td></tr></table></figure><br>对于MSVC的cl，借用lib命令，这只是windows下开发，将cl编译产生的obj文件处理成lib库<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lib /OUT:test.lib test.obj</span><br></pre></td></tr></table></figure></p>
<h2 id="3-2-动态共享库生成"><a href="#3-2-动态共享库生成" class="headerlink" title="3.2 动态共享库生成"></a>3.2 动态共享库生成</h2><p><strong>（1）linux下的.so共享库</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -shared -fPIC -o lib$(FileNameNoExt).so $(FileNameNoExt).o</span><br></pre></td></tr></table></figure><br>也可以window下生成后先改名为dll文件通过链接生成exe.再改回so，因为g++寻找链接库时自动加后缀根据系统，但链接时库类型会根据内容判断。即会去找.dll尾缀文件当库，但找到后链接时更加库内容判断库实际是.so，运行exe时会寻找so尾缀库文件</p>
<p><strong>（2）window下的.dll共享库</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -shared -Wall -o lib$(FileNameNoExt).dll $(FileNameNoExt).o</span><br></pre></td></tr></table></figure><br>共享库源文件中若存在main函数，main函数会被忽略而不被编译为共享库。</p>
<p>对于MSVC的DLL，如前使用cl命令的/LD指令生成。</p>
<h2 id="3-3-共享库的链接"><a href="#3-3-共享库的链接" class="headerlink" title="3.3 共享库的链接"></a>3.3 共享库的链接</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o $(FileNameNoExt).exe -L &lt;SelfLibarayPath&gt; -l &lt;LibNameWithoutExtAndPrefix&gt; $(FileNameNoExt)(.o/.cpp/.c)</span><br></pre></td></tr></table></figure>
<p>若为.o文件，只需链接不需编译。注意：-l后库名不包含规范前缀lib和尾缀.so/.a/.dll, 会更据系统选择动态库尾缀.dll /.so，g++会自动加上，如-ltools =&gt; libtools.so/libtools.a, 两个都存在默认选静态库，想选静态库可以直接多文件链接方法，如多个.o一样， -L参数不指定库文件路径，则会去标准库路径找</p>
<p>静态库链接原理示意如下，链接器会将静态库中所需目标文件与主文件链接在一起生成可执行文件。</p>
<img src="/2021/05/13/cpp/linker.png" class="" title="link">
<h1 id="四、Editplus命令配置"><a href="#四、Editplus命令配置" class="headerlink" title="四、Editplus命令配置"></a>四、Editplus命令配置</h1><p>注意用的共享库是自定义的libtools.dll/libtools.so/libtools.a&lt;/br&gt;<br>编译+链接+执行：<code>g++ $(FileName) -I &quot;$(FileDir)&quot; -L &quot;$(FileDir)&quot; -ltools -o $(FileNameNoExt).exe &amp;&amp; $(FileNameNoExt)</code>&lt;/br&gt;<br>编译：<code>g++ -c $(FileName) -I &quot;$(FileDir)&quot; -o $(FileNameNoExt).o</code>&lt;/br&gt;<br>链接：<code>g++ $(FileNameNoExt).o -L &quot;$(FileDir)&quot; -o $(FileNameNoExt).exe -ltools</code>&lt;/br&gt;<br>执行：<code>$(FileNameNoExt)</code>&lt;/br&gt;<br>DLL动态库编译：<code>g++ -shared -Wall -o lib$(FileNameNoExt).dll $(FileName</code>br&gt;<br>SO动态库编译：<code>g++ -shared -fPIC -o lib$(FileNameNoExt).so $(FileName)</code>&lt;/br&gt;</p>
<h1 id="五、C-对象创建的两种方式"><a href="#五、C-对象创建的两种方式" class="headerlink" title="五、C++对象创建的两种方式"></a>五、C++对象创建的两种方式</h1><p>在C++里面可以new对象，也可以直接声明对象。</p>
<h2 id="5-1-C-编译器内存区域划分"><a href="#5-1-C-编译器内存区域划分" class="headerlink" title="5.1 C++编译器内存区域划分"></a>5.1 C++编译器内存区域划分</h2><p>1.<strong>静态存储区域</strong>：主要保存全局变量和静态变量。 生存期：整个程序。static关键字</p>
<p>2.<strong>堆</strong>：存储动态生成的变量。生存期：自己来决定。需要手动释放内存。</p>
<p>3.<strong>栈</strong>：存储调用函数相关的变量和地址等。生存期：所处的语句块（既{}的范围）</p>
<p>对于一个自定义类Person， 有两种创建对象的方式</p>
<h2 id="5-2-声明对象与对象数组"><a href="#5-2-声明对象与对象数组" class="headerlink" title="5.2 声明对象与对象数组"></a>5.2 声明对象与对象数组</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Person <span class="title">person</span><span class="params">(name, id)</span></span>;</span><br><span class="line">Tricycle car[<span class="number">2</span>]; <span class="comment">//无参数构造器</span></span><br><span class="line">Tricycle car[<span class="number">2</span>] &#123;&#123;<span class="string">&quot;A0001&quot;</span>&#125;, &#123;<span class="string">&quot;A0002&quot;</span>&#125;&#125;;<span class="comment">//有参数构造器</span></span><br><span class="line">Tricycle car[] = &#123;<span class="built_in">Tricycle</span>(<span class="string">&quot;A00011&quot;</span>), <span class="built_in">Tricycle</span>(<span class="string">&quot;A00012&quot;</span>)&#125;; <span class="comment">//这种数组形式也可</span></span><br></pre></td></tr></table></figure>
<p>在声明的时候，C++编译器在<strong>栈</strong>中给它分配了一个空间存放所有的成员变量，但是为了节约内存空间，成员函数 被存放在了一个公共区域，这个类的所有的对象都可以共同享有。调用这个对象的成员变量和成员函数时用“.”操作符。对于对象数组，分为无参数构造和有参数构造</p>
<h2 id="5-3-new关键字创建对象"><a href="#5-3-new关键字创建对象" class="headerlink" title="5.3 new关键字创建对象"></a>5.3 new关键字创建对象</h2><p><strong>（1）创建单个对象</strong></p>
<p><code>Person * person = new Person(name, id)</code></p>
<p>若采用<code>Person person = * new Person()</code>的形式，实际上左右两边对象指针并不相同，左侧通过声明分配了栈内存空间，右侧通过new关键字分配了堆内存空间，这样的创建会导致堆内存无法释放而产生内存泄漏。若需要直接获取对象，可以改成<strong>对象引用</strong>的形式, 以“&amp;”操作符声明一个对象的引用person1，这种形式更类似于java的对象创建。引用的指针与对象的指针指向相同内存地址。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Person <span class="title">person0</span><span class="params">(<span class="string">&quot;Zhang Hongning&quot;</span>, <span class="string">&quot;332527197608218532&quot;</span>)</span></span>;</span><br><span class="line">Person &amp; person1 = person0; <span class="comment">//关于person0的引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这种形式更像java创建对象，左边只是声明引用而没有分配空间</span></span><br><span class="line">Person &amp; person2 = *<span class="keyword">new</span> <span class="built_in">Person</span>(<span class="string">&quot;Zhang Hongning&quot;</span>,<span class="string">&quot;332527197608218532&quot;</span>);</span><br></pre></td></tr></table></figure></p>
<p>对象引用使用时必须确保引用的对象在作用域内。如作用域在函数内的对象不能将引用返回到函数外。否则会报错或产生不可预料结果。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string &amp; <span class="title">getPerson</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	string name = <span class="string">&quot;Zhang hongning&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string &amp; str = <span class="built_in">getPerson</span>();<span class="comment">//会有warning或bug，引用的对象已经销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面方法正常编译, 因为是new创建的堆内存对象。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string &amp; <span class="title">getPerson</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	string * name = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;Zhang hongning&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> * name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string &amp; str = <span class="built_in">getPerson</span>();<span class="comment">//没有warnings</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>（2）通过无参数构造器创建对象数组</strong></p>
<p><code>Person * persons = new Person[2]</code></p>
<p>对象数组的数据结构示意<br>
<img src="/2021/05/13/cpp/objectArray.png" class="" title="objectArray">
</p>
<p><strong>（3）通过有参数构造器创建对象数组</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person * persons2 = <span class="keyword">new</span> Person[<span class="number">2</span>] &#123;</span><br><span class="line">		&#123;<span class="string">&quot;zhang hongning&quot;</span>, <span class="string">&quot;332526&quot;</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;zhang san&quot;</span>, <span class="string">&quot;332527&quot;</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>通过new创建的实例返回的是对象指针, 并在<strong>堆</strong>中分配了空间，需要程序员显式释放空间，与delete或delete [] 操作对应。否则会导致内存泄漏。此时的对象数组无法用sizeof获取数组大小，sizeof(person2) == sizeof(person2[0])。</p>
<p>不过，可以通过创建对象<strong>指针数组</strong>的形式，从而可以获得数组大小。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Tricycle * car[] = &#123;</span><br><span class="line">	<span class="keyword">new</span> <span class="built_in">Tricycle</span>(<span class="string">&quot;A0003&quot;</span>),</span><br><span class="line">	<span class="keyword">new</span> <span class="built_in">Tricycle</span>(<span class="string">&quot;A0004&quot;</span>),</span><br><span class="line">	<span class="keyword">new</span> <span class="built_in">Tricycle</span>(<span class="string">&quot;A0005&quot;</span>)</span><br><span class="line">&#125;;</span><br><span class="line">std::cout &lt;&lt; (<span class="built_in">sizeof</span>(car)/<span class="built_in">sizeof</span>(Tricycle *)) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;<span class="comment">//数组大小为3，每个元素是对象指针</span></span><br></pre></td></tr></table></figure></p>
<p><strong>（4）销毁对象</strong></p>
<p><code>delete person</code></p>
<p>detete对象时会调用对象的析构函数销毁对象。对象指针直接调用对象成员变量可以使用指向操作符“-&gt;”</p>
<p>delete对象时会自动调用对象的析构函数，但值得注意的是，储存在栈中的成员变量在对象被销毁时会被编译器自动销毁，包括通过声明构建的成员对象和基本类型。</p>
<p>但通过new关键字创建的成员对象（即保存在堆内存中的对象）需要在析构函数中显式地释放内存空间，否则会在程序结束时也无法释放而导致内存泄漏。故需注意对象中是否有储存在堆中的属性。</p>
<p>delete关键字用于对象数组，只会数组所占内存空间（上图矩形部分）并销毁首个元素对象并调用去析构函数。而上图椭圆部分剩余几个对象并未被释放且程序结束也不会释放而导致内存泄漏。</p>
<p>但如果是基本类型数组，由于其数据结构不存在椭圆部分，仅存在一个连续的数组内存空间保存基本类型值，故当delete操作能够完全释放基本类型数组。</p>
<p>对成员变量定义在栈中的对象，以Tricycle为例<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Person <span class="title">owner</span><span class="params">(<span class="string">&quot;h&quot;</span>, <span class="string">&quot;zz&quot;</span>)</span></span>;<span class="comment">//在栈内存创建实参Person</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;实参Person owner\t&quot;</span> &lt;&lt; &amp;owner &lt;&lt; endl;</span><br><span class="line">Tricycle * car = <span class="keyword">new</span> <span class="built_in">Tricycle</span>(<span class="string">&quot;A0001&quot;</span>, owner);</span><br><span class="line"><span class="keyword">delete</span> car;</span><br></pre></td></tr></table></figure><br>结果输出如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">实参Person owner	0x61fce0</span><br><span class="line">create Person whose point is 0x2562500 //car对象成员变量创建</span><br><span class="line">构造函数形参Person owner 0x61fdb0</span><br><span class="line">create Tricycle whose point is 0x25624e0 //car对象创建</span><br><span class="line">delete Person whose point is 0x61fdb0 //构造器栈中形参用完自动销毁</span><br><span class="line">delete Tricycle whose point is 0x25624e0 //delete销毁car对象本身</span><br><span class="line">delete Person whose point is 0x2562500 //car对象成员变量销毁</span><br><span class="line">delete Person whose point is 0x61fce0 //main介绍自动销毁栈中实参</span><br></pre></td></tr></table></figure><br>由上看出形参存储在栈内存中，构造器用完自动销毁形参，而实参是在外面主函数范围内，最后才自动销毁。</p>
<p>创建car对象时，先在栈内存中创建成员变量owner，再创建car对象，上例中对象储存中堆内存中。故需要delete销毁</p>
<p>delete销毁car时，先销毁car对象自身，car对象结束生命周期后，其栈内存中的成员变量owner被自动销毁。</p>
<p><strong>（5）销毁对象数组</strong></p>
<p><code>delete [] persons</code></p>
<p>销毁对象数组及数组中的元素，会逐一调用每个对象的析构函数。</p>
<h1 id="六、指针"><a href="#六、指针" class="headerlink" title="六、指针"></a>六、指针</h1><h2 id="1-指针的本质"><a href="#1-指针的本质" class="headerlink" title="1. 指针的本质"></a>1. 指针的本质</h2><p>指针本质上是C++编译器储存各类数据类型内存地址和数据类型的一种特殊变量，是一种特殊的整数类型，保存在<strong>栈</strong>中。指针所指内存区域大小由编译器判断。<strong>理解指针本质就能很好理解为何numpy的数据统一保存在一个char类型指针所指数组中</strong>。</p>
<h2 id="2-内存泄露、内存释放与指针悬摆"><a href="#2-内存泄露、内存释放与指针悬摆" class="headerlink" title="2. 内存泄露、内存释放与指针悬摆"></a>2. 内存泄露、内存释放与指针悬摆</h2><p><strong>内存泄漏</strong>（Memory Leak）是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。因此在使用完毕后应当使用delete操作符手动释放占据的堆内存。delete操作符的参数是指向该内存地址的指针，删除完毕后的指针仍然指向该地址，是为<strong>悬摆指针</strong>，对悬摆指针进行操作会造成错误，<strong>应当将delete后的指针赋值为空指针</strong>（nullptr/NULL/0）,下面定义data在释放内存后再次调用指针会产生不可预料的错误。因为编译器会认为这里是没有东西而另行他用，通过悬摆指针修改内存会导致他用产生问题。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * data = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">*data = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\t%p\n&quot;</span>, *data, data);</span><br><span class="line"><span class="keyword">delete</span> data;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\t%p\n&quot;</span>, *data, data); <span class="comment">//值为莫名其妙的值而非5</span></span><br></pre></td></tr></table></figure></p>
<h2 id="3-常量指针与常量成员函数"><a href="#3-常量指针与常量成员函数" class="headerlink" title="3. 常量指针与常量成员函数"></a>3. 常量指针与常量成员函数</h2><p>常量由const关键字定义，注意由宏命令<code>#define</code>的常量实际上在进入编译器时已经替换成为字面量，故它不存在指针操作。常量无法用指针修改值<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> * pcdata = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\t%p\n&quot;</span>, *pcdata, pcdata);</span><br><span class="line">*pcdata = <span class="number">6</span>; <span class="comment">//报错，无法修改常量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DATA 7</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\t%p\n&quot;</span>, DATA, &amp;DATA); <span class="comment">//报错，不能进行取指针操作</span></span><br></pre></td></tr></table></figure><br>对象如果是常量声明，那么只能调用常量函数，常量对象与常量函数均由const修饰<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Person * owner = <span class="keyword">new</span> <span class="built_in">Person</span>(<span class="string">&quot;Zhang hongning&quot;</span>, <span class="string">&quot;3538&quot;</span>);</span><br><span class="line">cout &lt;&lt; owner-&gt;<span class="built_in">getName</span>() &lt;&lt; endl;<span class="comment">//getName声明为常量函数</span></span><br><span class="line">owner -&gt; <span class="built_in">setName</span>(<span class="string">&quot;zju&quot;</span>);<span class="comment">//报错，修改常量对象</span></span><br></pre></td></tr></table></figure><br>在实践中，经常将函数形参声明为常量指针，这样得到的形参对象是常量对象，从而将对象本身传递给函数的同时避免函数对对象的修改。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Person <span class="title">person</span><span class="params">(<span class="string">&quot;Zhang&quot;</span>, <span class="string">&quot;ID&quot;</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getName</span><span class="params">(<span class="type">const</span> Person * person)</span> </span>&#123;</span><br><span class="line">	person -&gt; <span class="built_in">getName</span>();<span class="comment">//正常</span></span><br><span class="line">	person -&gt; <span class="built_in">setName</span>(<span class="string">&quot;ZHN&quot;</span>);<span class="comment">//编译器报错</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">getName</span>(&amp;person);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>由于形参声明是常量，故无论实参是否为常量均被视为常量。但若形参为变量，那么实参必须为变量才能通过编译。</p>
<h1 id="七、对象重载构造器共享代码"><a href="#七、对象重载构造器共享代码" class="headerlink" title="七、对象重载构造器共享代码"></a>七、对象重载构造器共享代码</h1><h2 id="1-placement-new策略"><a href="#1-placement-new策略" class="headerlink" title="1.placement new策略"></a>1.placement new策略</h2><p>通过new(this)覆盖原先，注意new Tricycle会创建新的对象而非在原先内存上覆盖<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> (<span class="keyword">this</span>) <span class="built_in">Tricycle</span>(license, <span class="keyword">new</span> <span class="built_in">Person</span>(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;00001&quot;</span>));</span><br></pre></td></tr></table></figure></p>
<h2 id="2-通过函数默认值"><a href="#2-通过函数默认值" class="headerlink" title="2.通过函数默认值"></a>2.通过函数默认值</h2><p>类函数默认值一般在声明中描述，声明与定义不能重复默认值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Tricycle</span>(string, Person * owner = <span class="keyword">new</span> <span class="built_in">Person</span>(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;00001&quot;</span>))</span><br></pre></td></tr></table></figure></p>
<h2 id="3-成员函数共享"><a href="#3-成员函数共享" class="headerlink" title="3.成员函数共享"></a>3.成员函数共享</h2><p>通过定义一个private的成员函数实现构造器通用部分,如init函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tricycle</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">//初始化代码块</span></span><br><span class="line">		&#125;;</span><br><span class="line">	<span class="keyword">public</span>：</span><br><span class="line">		<span class="built_in">Tricycle</span>()&#123;<span class="built_in">init</span>();&#125;</span><br><span class="line">		<span class="built_in">Tricycle</span>(string) &#123;<span class="built_in">init</span>();&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="4-委托构造函数"><a href="#4-委托构造函数" class="headerlink" title="4.委托构造函数"></a>4.委托构造函数</h2><p>自C++ 11开始，可以在构造函数实现中委托另外一个构造函数完成部分任务。</p>
<p>构造函数由<strong>初始化部分</strong>和<strong>函数体</strong>组成，其中初始化部分在函数体前形参声明后面，以“:”开始。在这个地方可以用<code>成员变量名（初始化参数）</code>的形式初始化，也可以调用其他成员函数进行构造。在java中，构造器使用大大简化，所有初始化均在函数体内完成，通过this()调用其他重载构造器，通过super()调用父构造器。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Tricycle::<span class="built_in">Tricycle</span>(string license):<span class="built_in">Tricycle</span>(license, <span class="keyword">new</span> <span class="built_in">Person</span>(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;00001&quot;</span>)) &#123;</span><br><span class="line">	<span class="comment">//构造器其他任务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Tricycle::<span class="built_in">Tricycle</span> ():<span class="built_in">license</span>(<span class="string">&quot;A00001&quot;</span>), <span class="built_in">owner</span>(<span class="keyword">new</span> <span class="built_in">Person</span>(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;00001&quot;</span>)) &#123;</span><br><span class="line">	<span class="comment">//构造器函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>对于常量和引用，由于无法进行赋值修改，必须在初始化区域初始化。对于变量，可以再函数体中用“=”进行调用<strong>复制构造函数</strong>初始化。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tricycle</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">const</span> string license;</span><br><span class="line">		<span class="type">const</span> Person * owner;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该形式编译器报错</span></span><br><span class="line">Tricycle::<span class="built_in">Tricycle</span> (string license, Person * owner) &#123;</span><br><span class="line">	<span class="keyword">this</span> -&gt; license = license;</span><br><span class="line">	<span class="keyword">this</span> -&gt; owner = owner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该形式通过编译</span></span><br><span class="line">Tricycle::<span class="built_in">Tricycle</span>(string license, Person * owner) :<span class="built_in">license</span>(license), <span class="built_in">owner</span>(owner) &#123;</span><br><span class="line">	<span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="八、高级函数"><a href="#八、高级函数" class="headerlink" title="八、高级函数"></a>八、高级函数</h1><h2 id="1-复制构造函数"><a href="#1-复制构造函数" class="headerlink" title="1. 复制构造函数"></a>1. 复制构造函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Person <span class="title">person0</span><span class="params">()</span></span>;</span><br><span class="line">Person person1 = person0;</span><br></pre></td></tr></table></figure>
<p>对于上述操作，等号的赋值会将person0的成员变量全部拷贝给person1，这个过程是由Person类的复制构造函数完成的。复制构造函数与构造函数属于重载函数的关系，其形参为一个待复制对象的引用，一般声明为常量引用。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person &amp; person);</span><br></pre></td></tr></table></figure><br>和构造函数一样，若用户为定义，编译器会自动提供一个默认复制构造函数，默认构造函数对成员变量是浅复制。默认构造函数形式推理如下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Tricycle</span> (<span class="type">const</span> Tricycle &amp; car) &#123;</span><br><span class="line">	license = car.license;<span class="comment">//对象变量，调用复制构造函数</span></span><br><span class="line">	owner = car.owner;<span class="comment">//指针变量，共用指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>故对于指针或者引用类型的成员变量，会共享，一旦delete会导致另外一个对象访问该指针或引用所指地址出现错误。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Tricycle &amp; car0 = *<span class="keyword">new</span> <span class="built_in">Tricycle</span>(<span class="string">&quot;A0001&quot;</span>);</span><br><span class="line">Tricycle car1 = car0;</span><br><span class="line">std::cout &lt;&lt; car0.<span class="built_in">getOwner</span>() &lt;&lt; <span class="string">&#x27;\t&#x27;</span> &lt;&lt; car1.<span class="built_in">getOwner</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">delete</span> &amp;car0;</span><br><span class="line">Person * tmp = car1.<span class="built_in">getOwner</span>();</span><br><span class="line">std::cout &lt;&lt; *tmp &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;<span class="comment">//此时解引用会报错，指针所指内存地址已经释放</span></span><br></pre></td></tr></table></figure><br>为了避免浅复制所导致的问题，一般会对有指针/引用成员变量的类自定义复制构造函数，例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Tricycle</span> (<span class="type">const</span> Tricycle &amp; car) &#123;</span><br><span class="line">	license = car.license;<span class="comment">//对象变量，调用复制构造函数</span></span><br><span class="line">	owner = <span class="keyword">new</span> Person;<span class="comment">//重新分配内存地址</span></span><br><span class="line">	*owner = *(car.owner);<span class="comment">//调用Person复制构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-移动构造函数"><a href="#2-移动构造函数" class="headerlink" title="2.移动构造函数"></a>2.移动构造函数</h2><h1 id="8-2-1-左值与右值"><a href="#8-2-1-左值与右值" class="headerlink" title="8.2.1 左值与右值"></a>8.2.1 左值与右值</h1><p>左值指的是具名的、可获取指针的、生命周期较为长久的数据类型，右值指的是不具名的、无法获取指针的、临时数据类型。由于左值一般居于等号左侧，右值居于等号右侧，因此得名。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;<span class="comment">//a为左值，字面量1为右值；</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getDouble</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span> *a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> b = <span class="built_in">getDouble</span>(a);<span class="comment">//a，b为左值，getDouble(a)返回值为右值</span></span><br></pre></td></tr></table></figure></p>
<h1 id="8-2-2-左值引用与右值引用"><a href="#8-2-2-左值引用与右值引用" class="headerlink" title="8.2.2 左值引用与右值引用"></a>8.2.2 左值引用与右值引用</h1><p>左值引用即我们常见的对具名变量的引用，通过单修饰符“&amp;”声明。为了对右值进行更加有效利用，改变右值变量的临时性，在C++ 11中引入了右值引用，用双修饰符“&amp;&amp;”声明。右值引用能够有效减少不必要的临时内存开销。注意，右值引用本身是一个左值，故而可以持久存在。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> v = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> &amp; vl = v;<span class="comment">//左值引用 </span></span><br><span class="line"><span class="type">int</span> &amp; a = <span class="number">1</span>;<span class="comment">//编译报错，右值无法创建直接左值引用</span></span><br><span class="line"><span class="type">int</span> &amp;&amp; vr = <span class="number">1</span>;<span class="comment">//右值引用</span></span><br><span class="line"><span class="type">int</span> &amp;&amp; b = v;<span class="comment">//编译报错，左值无法创建右值引用</span></span><br><span class="line">vl= vr;<span class="comment">//将右值引用的值拷贝给左值引用</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp; vc = <span class="number">1</span>;<span class="comment">//常量左值引用可以用于常量/变量的左右值，算是奇葩，但是是常量而无法修改</span></span><br></pre></td></tr></table></figure></p>
<h1 id="8-2-3-移动构造函数"><a href="#8-2-3-移动构造函数" class="headerlink" title="8.2.3 移动构造函数"></a>8.2.3 移动构造函数</h1><p>拷贝构造函数是将右值或左值创建一个常量左值引用，并分配新内存给新建对象，复制参数。如使用右值作为初始化参数，右值只是临时使用了一块内存，有点浪费。在C++ 11中引入了移动构造函数，参数类型是一个右值引用，编译器会将新对象的指针指向当前右值参数，故而无需重新分配对象内存空间。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Tricycle</span> (Tricycle &amp;&amp; car):<span class="built_in">license</span>(car.license),<span class="built_in">owner</span>(car.owner) &#123;</span><br><span class="line">	car.owner=<span class="literal">nullptr</span>;<span class="comment">//必须将右值的指针成员变量指向空，不然右值析构会销毁它</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在调用时，若有声明移动构造函数，右值参数优先传给移动构造函数。若没有，由于拷贝构造函数参数类型是常量左值引用，可以接受右值参数而进行拷贝构造。</p>
<h2 id="3-编译阶段常量表达式"><a href="#3-编译阶段常量表达式" class="headerlink" title="3.编译阶段常量表达式"></a>3.编译阶段常量表达式</h2><p>编译阶段，C++编译器会将代码进行尽量的优化，例如会将#define定义的宏常量全部替换为字面量<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DATA 1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, DATA);   =&gt;   <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><br> 也会把const常量进行必要的整合，如下面会将2006与10计算后存储。而非保存两个量。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> decade = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> year = <span class="number">2006</span> + decade;   =&gt; <span class="type">int</span> year = <span class="number">2026</span>;</span><br></pre></td></tr></table></figure><br>类似的，针对<code>2006 + getValue()</code>这样含有函数表达式的例子，C++引入了常量表达式，这是一种特殊的函数，用constexpr修饰，且必须有返回值，返回值只能保含字面量或其他常量表达式。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">getCentury</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">22</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">double</span> <span class="title">getPi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">double</span>) <span class="built_in">getCentury</span>() /<span class="number">7</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="九、运算符与运算符重载"><a href="#九、运算符与运算符重载" class="headerlink" title="九、运算符与运算符重载"></a>九、运算符与运算符重载</h1><p>C++中的运算符分为一元、二元与三元运算符。一元运算符有!、++、—等，二元运算符有=、==、&lt;=、&gt;=、!=、&amp;&amp;、||、+、-、<em>、/、%等，三元运算符有?:等。其运算符应用规则与java基本一致。<br>只得一提的是，几乎所有C++运算符都支持运算符重载，即与特定的类函数关联。所有的运算符都有对应的函数返回值，等号“=”也不例外。但<strong>等号运算是右结合律</strong>，这与其他运算符不同。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m = <span class="number">6</span>;</span><br><span class="line"><span class="type">int</span> v = m=<span class="number">7</span>;</span><br><span class="line">cout &lt;&lt; m &lt;&lt; v;<span class="comment">//m和v都变成7，赋值运算右结合律</span></span><br></pre></td></tr></table></figure><br>在C++中，比较特殊的是逗号“，”也可以是一种运算符<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m = <span class="number">6</span>;</span><br><span class="line"><span class="type">int</span> v = (<span class="number">7</span>, m);<span class="comment">//v变成6，逗号运算会舍弃左侧值，但注意没有括号就变成了声明v,m两个变量，会报错，虽然正常也不会这样用。</span></span><br></pre></td></tr></table></figure><br>重载运算符+、-、</em>、/等可以简化类与类的计算代码，其重载基于类成员函数，形式如下,其中”SYMBOL”需要替换至具体运算符。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">returnType <span class="title">operatorSYMBOL</span><span class="params">(parameter list)</span></span>;</span><br></pre></td></tr></table></figure><br>下面以Counter类为例<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Counter</span>(<span class="type">int</span>);</span><br><span class="line">	~<span class="built_in">Counter</span>() &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getData</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="type">const</span> Counter&amp; <span class="keyword">operator</span>++(); <span class="comment">//prefix ++运算符</span></span><br><span class="line">	<span class="type">const</span> Counter <span class="keyword">operator</span>++(<span class="type">int</span>);<span class="comment">//postfix ++运算符</span></span><br><span class="line">		<span class="type">const</span> Counter <span class="keyword">operator</span>=(<span class="type">const</span> Counter &amp;);<span class="comment">//Counter a; a=b</span></span><br><span class="line">		<span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span></span>;<span class="comment">//对象转int</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="1-自增运算符"><a href="#1-自增运算符" class="headerlink" title="1. 自增运算符++"></a>1. 自增运算符++</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟 ++a，先+1再赋值</span></span><br><span class="line"><span class="type">const</span> Counter &amp; Counter::<span class="keyword">operator</span>++() &#123;</span><br><span class="line">	data ++;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟a++, 先赋值再+1，为了区别++a，有形参int</span></span><br><span class="line"><span class="type">const</span> Counter Counter::<span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">	<span class="function">Counter <span class="title">tmp</span><span class="params">(*<span class="keyword">this</span>)</span></span>; <span class="comment">//调用复制构造函数</span></span><br><span class="line">	data++;</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-加法运算符"><a href="#2-加法运算符" class="headerlink" title="2. 加法运算符+"></a>2. 加法运算符+</h2><p>对于二元运算<code>c1 + c2</code>，C++编译器将其看成<code>c1.operator+(c2)</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Counter Counter::<span class="keyword">operator</span>+(<span class="type">const</span> Counter &amp; beta) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Counter</span>(data + beta.<span class="built_in">getData</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-赋值运算符"><a href="#3-赋值运算符" class="headerlink" title="3. 赋值运算符="></a>3. 赋值运算符=</h2><p>对于声明变量时赋值运算，调用的是复制构造函数来构建对象。但对于已经声明的变量，赋值运算调用重载赋值运算函数operator=();其操作与复制构造函数相似，但不用重新创建对象。该方法与构造函数、析构函数、复制构造函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Counter Counter::<span class="keyword">operator</span>=(<span class="type">const</span> Counter &amp; beta) &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span> == &amp;beta) &#123;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果是指针成员，注意深浅复制区别</span></span><br><span class="line">	data = beta.<span class="built_in">getData</span>();</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>与复制构造函数、移动构造函数对应，有复制赋值运算（如上）和移动赋值运算（如下），区别也是在于左右值引用。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Counter Counter::<span class="keyword">operator</span>=(Counter &amp;&amp; beta) &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span> == &amp;beta) &#123;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果是指针成员，注意深浅复制区别</span></span><br><span class="line">	data = beta.data;</span><br><span class="line">	beta.data = <span class="literal">nullptr</span>;<span class="comment">//原因与移动构造函数一样</span></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>故同样需要同复制构造函数那样考虑深浅复制问题，且如果自我赋值需要防止空对象。</strong></p>
<h2 id="4-转换运算"><a href="#4-转换运算" class="headerlink" title="4. 转换运算"></a>4. 转换运算</h2><p><strong>（1）内置类型转对象</strong><br>这个过程的实现本质上与复制构造函数一样，复制构造函数的参数类型为当前类的实例的引用，而这里将参数类型改为内置类型。这里函数即是普通的重载构造器，又是转换运算。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Counter::<span class="built_in">Counter</span>(<span class="type">int</span> val):<span class="built_in">data</span>(val) &#123;&#125;</span><br><span class="line">Counter c = <span class="number">16</span>;</span><br></pre></td></tr></table></figure><br><strong>（2）对象转内置类型</strong><br>这个过程通过一个无返回值声明的operator成员函数实现，形式为<code>operator type()</code>,type可替换为其他内置类型<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Counter::<span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ios_base::<span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//这是IO流判断到达尾部的方法，如while(cin)&#123;&#125;, 形式上类似Perl语言的while(&lt;STDIN&gt;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>值得一提的是，在Java中并不支持开发者重载运算符。java唯一自己重载的运算符是“+”，用于字符串拼接。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java源码</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span> + <span class="string">&quot;bcd&quot;</span>;</span><br><span class="line"><span class="comment">//编译后转换, java开发更推荐使用StringBuilder</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;abc&quot;</span>)).apend(<span class="string">&quot;bcd&quot;</span>).toString();</span><br></pre></td></tr></table></figure></p>
<h1 id="十、类的继承与多态"><a href="#十、类的继承与多态" class="headerlink" title="十、类的继承与多态"></a>十、类的继承与多态</h1><h2 id="1-继承"><a href="#1-继承" class="headerlink" title="1. 继承"></a>1. 继承</h2><p>C++类继承与java类似，只是形式不同。 但C++支持多继承，被继承类之间用逗号隔开<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Children: &lt;权限修饰符&gt; Father1,&lt;权限修饰符&gt; Father2, ... &#123;&#125;;//C++</span><br><span class="line">&lt;权限修饰符&gt; class Chidren extands Father implements &lt;接口1&gt;, &lt;接口2&gt; &#123;&#125;//Java, 权限修饰与C++意义不同</span><br><span class="line">class Chidren(Father): //Python</span><br></pre></td></tr></table></figure></p>
<h2 id="2-权限修饰符"><a href="#2-权限修饰符" class="headerlink" title="2. 权限修饰符"></a>2. 权限修饰符</h2><p>与Java类似，C++有public、protected和private三种权限修饰符。public/protected修饰的成员变量或方法能够被子类继承访问，private修饰的只能在类内访问。与Java不同的是，C++中没有包的概念，只有public类型的成员变量或成员方法能被外部访问，而java中protected修饰能在相同包内访问。此外C++中虽然没有类本身的权限修饰，像java那样public class，但是对类的继承有权限修饰。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">权限修饰符</th>
<th style="text-align:left">自身成员权限控制</th>
<th style="text-align:left">父类成员权限控制</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">public</td>
<td style="text-align:left">可以外部访问、继承</td>
<td style="text-align:left">公有继承</td>
</tr>
<tr>
<td style="text-align:left">protected</td>
<td style="text-align:left">无法外部访问，可以被继承</td>
<td style="text-align:left">保护继承</td>
</tr>
<tr>
<td style="text-align:left">private</td>
<td style="text-align:left">无法外部访问，无法被继承</td>
<td style="text-align:left">私有继承</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Chinese</span>:<span class="keyword">public</span> Person &#123;&#125;; <span class="comment">//公有继承：继承Person类中public/protected的成员,并设为自身的public成员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chinese</span>:<span class="keyword">protected</span> Person &#123;&#125;; <span class="comment">//保护继承：继承Person类中public/protected的成员，并设为自身的protected成员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chinese</span>:<span class="keyword">private</span> Person &#123;&#125;; <span class="comment">//私有继承：继承Person类中public/protected的成员，并设为自身的private成员</span></span><br></pre></td></tr></table></figure>
<h2 id="3-继承类的构造与销毁"><a href="#3-继承类的构造与销毁" class="headerlink" title="3. 继承类的构造与销毁"></a>3. 继承类的构造与销毁</h2><p>继承类的构造与销毁其实是<strong>按照堆栈的出入顺序</strong>分别调用各级继承类的构造函数和析构函数完成构造与销毁。如下所示。创建时先调用父类构造器，再调用子类构造器，销毁时调用析构的顺序则相反，类似于先近后出的堆栈逻辑。当多继承时，在类声明中位置较前的父类先构造，后销毁。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Chinese</span>:<span class="keyword">public</span> Person &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">	string name_CN;</span><br><span class="line">	string nation;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Chinese</span>(string, string, string, string);</span><br><span class="line">	<span class="built_in">Chinese</span>(string, string);</span><br><span class="line">	~<span class="built_in">Chinese</span>();</span><br><span class="line">	<span class="function">string <span class="title">getChineseName</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function">string <span class="title">getNation</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Chinese * chinese = <span class="keyword">new</span> <span class="built_in">Chinese</span>(<span class="string">&quot;ZHN&quot;</span>, <span class="string">&quot;310058&quot;</span>, <span class="string">&quot;张洪宁&quot;</span>, <span class="string">&quot;Han&quot;</span>);</span><br><span class="line">	<span class="keyword">delete</span> chinese;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输出：</span><br><span class="line">create Person whose point is 0xff64c0</span><br><span class="line">create Chinese Person whose point is 0xff64c0</span><br><span class="line">delete Chinese Person whose point is 0xff64c0</span><br><span class="line">delete Person whose point is 0xff64c0</span><br></pre></td></tr></table></figure><br><strong>继承类的构造参数传递</strong><br>若构建继承类时有父类的参数传入，可以在构造函数的初始化区调用父类构造函数初始化。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Chinese::<span class="built_in">Chinese</span>(string name, string id, string name_CN, string nation):<span class="built_in">Person</span>(name, id),<span class="built_in">name_CN</span>(name_CN),<span class="built_in">nation</span>(nation) &#123;<span class="comment">//调用了Person构造函数</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;create Chinese Person whose point is &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="4-函数覆盖（重写）与多态"><a href="#4-函数覆盖（重写）与多态" class="headerlink" title="4. 函数覆盖（重写）与多态"></a>4. 函数覆盖（重写）与多态</h2><p><strong>函数覆盖</strong></p>
<p>java和C++都支持在子类中覆盖父类的函数，重新定义一个符合子类要求的函数。<strong>函数覆盖要求与父类的函数返回类型及函数签名（函数名+形参类型+形参顺序）相同</strong>。</p>
<p>值得注意的是，若父类函数有多个重载函数，覆盖一个，其他几个也无法使用，以免造成不必要的错误。</p>
<p>但是，若还想调用父类的成员函数（包括被覆盖的），需要用全限定名调用<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Chinese.Person::<span class="built_in">getName</span>(); <span class="comment">//类似java和python的super</span></span><br><span class="line">rect-&gt;Shape::<span class="built_in">draw</span>();<span class="comment">//指针形式</span></span><br></pre></td></tr></table></figure><br><strong>虚成员函数与多态</strong><br>在java中可以采用父类声明而子类初始化的形式实现多态性，在C++中也是类似。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person * chinese = <span class="keyword">new</span> Chinese;<span class="comment">//C++多态</span></span><br><span class="line">Person chinese = <span class="keyword">new</span> <span class="built_in">Chinese</span>();<span class="comment">//Java多态</span></span><br></pre></td></tr></table></figure><br>但C++与java不同之处在于，java在多态声明时，若调用重写函数，会自动调用子类的函数。而C++默认调用父类函数。因此，C++中为了支持多态，引入了<strong>虚成员函数</strong>。在父类将待重写函数声明为虚成员函数后即会自动调用子类重写函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person * chinese = <span class="keyword">new</span> <span class="built_in">Chinese</span>(<span class="string">&quot;ZHN&quot;</span>, <span class="string">&quot;310058&quot;</span>, <span class="string">&quot;张洪宁&quot;</span>, <span class="string">&quot;Han&quot;</span>);</span><br><span class="line">cout &lt;&lt; chinese -&gt; <span class="built_in">getName</span>() &lt;&lt; endl;<span class="comment">//输出的是父类结果ZHN</span></span><br></pre></td></tr></table></figure><br>虚成员函数用virtual修饰。其背后原理，很多编译器实际上创建<strong>虚成员函数表</strong>，里面保存了虚成员函数的指针。如前，在创建子类对象时，会先调用父类构造器，此时虚成员函数指针指向父类函数，当调用子类构造器，又会指向子类，从而实现了多态。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Person</span> (string, string);</span><br><span class="line">		<span class="keyword">virtual</span> ~<span class="built_in">Person</span> ();</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">		....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person * chinese = <span class="keyword">new</span> <span class="built_in">Chinese</span>(<span class="string">&quot;ZHN&quot;</span>, <span class="string">&quot;310058&quot;</span>, <span class="string">&quot;张洪宁&quot;</span>, <span class="string">&quot;Han&quot;</span>);</span><br><span class="line">cout &lt;&lt; chinese -&gt; <span class="built_in">getName</span>() &lt;&lt; endl;<span class="comment">//输出的是子类结果张洪宁</span></span><br></pre></td></tr></table></figure><br><strong>注意</strong>： 同java的多态一样，此时无法直接调用子类独有的方法，在java中必须进行强制转换。在C++中也是类似。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java实现强制转换，如不行会抛出ClassCastException</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">chinese</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chinese</span>(<span class="string">&quot;ZHN&quot;</span>, <span class="string">&quot;310058&quot;</span>, <span class="string">&quot;张洪宁&quot;</span>, <span class="string">&quot;Han&quot;</span>);</span><br><span class="line">System.out.println(((Chinese) chinese).getNation());</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++实现强制转换，但类型不兼容不会产生提示，指针任然指向原先地址，故一般不直接采用强制转换，除非你清楚</span></span><br><span class="line">Person *chinese = <span class="keyword">new</span> <span class="built_in">Chinese</span>(<span class="string">&quot;ZHN&quot;</span>, <span class="string">&quot;310058&quot;</span>, <span class="string">&quot;张洪宁&quot;</span>, <span class="string">&quot;Han&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person\t&quot;</span> &lt;&lt; ((Chinese *)chinese) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++用dynamic_cast &lt;目标指针指针类型&gt; (待转换指针)的形式，如果不可转会返回空指针，程序猿可以用条件语句进行判断</span></span><br><span class="line">Person *chinese = <span class="keyword">new</span> <span class="built_in">Chinese</span>(<span class="string">&quot;ZHN&quot;</span>, <span class="string">&quot;310058&quot;</span>, <span class="string">&quot;张洪宁&quot;</span>, <span class="string">&quot;Han&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person\t&quot;</span> &lt;&lt; (<span class="keyword">dynamic_cast</span> &lt;Chinese *&gt; (chinese))-&gt;<span class="built_in">getNation</span>() &lt;&lt; endl;<span class="comment">//正常</span></span><br><span class="line">Person * person = <span class="keyword">new</span> <span class="built_in">Person</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person\t&quot;</span> &lt;&lt; ((<span class="keyword">dynamic_cast</span> &lt;Chinese *&gt; (person)) == <span class="literal">nullptr</span>) &lt;&lt; endl;<span class="comment">//空指针</span></span><br></pre></td></tr></table></figure></p>
<p>同时由于多态本质上是创建了子类对象，所以<strong>一般会将析构函数也声明为虚成员函数</strong>，从而销毁释放子类对象（此时会先调用子类析构，再调用父类析构，同前）。</p>
<p><strong>切除</strong></p>
<p><strong>多态的本质是创建了指向子类对象的指针，并因为指针类型声明为父类而屏蔽了内存地址中子类独有部分</strong>，故多态的实现必须利用<strong>指针和引用</strong>，正如前面提到，java的声明初始化其实是一种类似C++引用的声明。下面这种按值传递，实际上是将子类对象复制给父类对象，调用了父类的复制构造函数，父类中不包含的部分自然而然就会被<strong>切除</strong>。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person chinese = <span class="built_in">Chinese</span>(<span class="string">&quot;ZHN&quot;</span>, <span class="string">&quot;310058&quot;</span>, <span class="string">&quot;张洪宁&quot;</span>, <span class="string">&quot;Han&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person\t&quot;</span> &lt;&lt; chinese.<span class="built_in">getName</span>() &lt;&lt; endl;<span class="comment">//输出父类参数“ZHN”, 子类信息缺失</span></span><br><span class="line"></span><br><span class="line">Person &amp;chinese = *<span class="keyword">new</span> <span class="built_in">Chinese</span>(<span class="string">&quot;ZHN&quot;</span>, <span class="string">&quot;310058&quot;</span>, <span class="string">&quot;张洪宁&quot;</span>, <span class="string">&quot;Han&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person\t&quot;</span> &lt;&lt; chinese.<span class="built_in">getName</span>() &lt;&lt; endl;<span class="comment">//输出子类参数“张洪宁”</span></span><br></pre></td></tr></table></figure></p>
<h2 id="5-抽象类"><a href="#5-抽象类" class="headerlink" title="5. 抽象类"></a>5. 抽象类</h2><p>在java中有抽象类与抽象方法的概念，它们通过abstract关键字来定义。抽象类无法直接创建自身对象，而必须由具体的实现子类来创建多态对象。在C++中也是类似。前面提到C++利用virtual关键字定义虚函数来实现类的多态，但这个父类和虚成员函数仍然可以直接创建并调用，C++再此基础上通过将虚成员函数初始化为0来表明当前函数是抽象的，必须在子类重写，从而实现了抽象类与抽象方法定义。初始化为0的虚函数称为<strong>纯虚函数</strong>。同样，抽象类可以局部实例化而产生一个子抽象类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;<span class="comment">//抽象类</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> string <span class="title">getName</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//纯虚函数，因为函数本身也是储存在指针所指地址的数据类型，故可以声明初始化。因为内容为0，必须覆盖</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chinese</span>: <span class="keyword">public</span> Person &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">string <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">Chinese::getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;张洪宁&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得一提的是，C++中抽象方法（纯虚函数）可以提供实现的函数体，但在java中抽象方法只能被覆盖重写，不能提供实现的函数体。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java, 会报错不通过编译</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;Zhang Hongning&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++, OK</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> string <span class="title">getName</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">Person::getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;zhn&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="十一、C-与系统的交互"><a href="#十一、C-与系统的交互" class="headerlink" title="十一、C++与系统的交互"></a>十一、C++与系统的交互</h1><h2 id="1-命令行参数的获取"><a href="#1-命令行参数的获取" class="headerlink" title="1. 命令行参数的获取"></a>1. 命令行参数的获取</h2><p>C++同java一样，在主方法处的形参可以获取命令行信息，操作由编译器与系统完成。(<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Allen-rg/p/6762437.html">https://www.cnblogs.com/Allen-rg/p/6762437.html</a>)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @param argc 整型,系统命令行参数个数</span></span><br><span class="line"><span class="comment">* @param argv[] 字符串指针数组，代表所有命令行参数，其中第一个是当前执行程序名</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java的主方法，由于java字符串数组自带长度属性，没有C++的第一个参数，此外java没有第一个值代表程序名</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">static</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-程序执行完毕的暂停"><a href="#2-程序执行完毕的暂停" class="headerlink" title="2. 程序执行完毕的暂停"></a>2. 程序执行完毕的暂停</h2><p>如下函数可实现系统那样的“按任意键继续…”<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);<span class="comment">//即bat脚本中的pause,若为pause&gt;nul，没有“任意键继续...”</span></span><br></pre></td></tr></table></figure></p>
<h1 id="十二、C-的IO操作"><a href="#十二、C-的IO操作" class="headerlink" title="十二、C++的IO操作"></a>十二、C++的IO操作</h1><h2 id="1-C-的IO方法类库体系"><a href="#1-C-的IO方法类库体系" class="headerlink" title="1. C++的IO方法类库体系"></a>1. C++的IO方法类库体系</h2>
	<img src="/2021/05/13/cpp/io.jpg" class="" title="io">

<h2 id="2-文件流fstream"><a href="#2-文件流fstream" class="headerlink" title="2.文件流fstream"></a>2.文件流fstream</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/codingmengmeng/p/5545042.html">https://www.cnblogs.com/codingmengmeng/p/5545042.html</a></p>
<p>数据流的概念与java中一样，文件流fstream中包括文件输出流ofstream、文件输入流ifstream和文件流fstream对象进行IO操作<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="function">fstream <span class="title">f</span><span class="params">(filename, ios::in)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (f.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">		string greet;</span><br><span class="line">		<span class="keyword">while</span> (<span class="built_in">getline</span>(f, greet)) &#123;</span><br><span class="line">			cout &lt;&lt; greet &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		f.<span class="built_in">close</span>();</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		std::cerr &lt;&lt; <span class="string">&quot;File Not Exists&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="十三、函数指针与Lambda表达式"><a href="#十三、函数指针与Lambda表达式" class="headerlink" title="十三、函数指针与Lambda表达式"></a>十三、函数指针与Lambda表达式</h1><p>函数也是一种数据类型，也有它的内存地址，因此函数也有它的指针。实际上，咱定义的函数的名称就可以理解为一个函数指针。但函数指针的创建与普通函数创建还是不一样的<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> (*functionPtr)(<span class="type">int</span>);<span class="comment">//声明函数指针，需要圆括号</span></span><br><span class="line"><span class="function"><span class="type">void</span> * <span class="title">functionPtr</span><span class="params">(<span class="type">int</span>)</span></span>;<span class="comment">//声明返回值为任意指针的函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">functionPtr</span>(<span class="number">10</span>);<span class="comment">//函数或函数指针的实现函数调用</span></span><br></pre></td></tr></table></figure><br>Lambda表达式是一种简单的函数创建形式，在C++中，其实际上是创建了一个函数并返回其函数指针。与否规则与java有类似之处。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++ Lambda，实际上创建的是函数的栈指针，可用auto进行类型推断，也可显式声明函数指针</span></span><br><span class="line"><span class="keyword">auto</span> functionptr0 = [local_val](<span class="type">int</span> x)&#123;<span class="keyword">return</span> x + <span class="number">1</span>;&#125;;<span class="comment">//[]声明使用的外部局部变量，()显式声明函数参数，&#123;&#125;为函数体</span></span><br><span class="line"><span class="built_in">int</span> (*functionptr1)() = []()-&gt;<span class="type">int</span>&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;<span class="comment">//可以用“-&gt;”指定返回类型，这与java对该符号的使用不同.</span></span><br><span class="line"><span class="built_in">functionptr0</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><br>值得注意的是，[]中外部局部变量的使用可以有多种策略，实现按引用传递、按值传递、全部使用、指定使用，<a target="_blank" rel="noopener" href="https://www.cnblogs.com/jimodetiantang/p/9016826.html">参见</a>。</p>
<h1 id="十四、线程与进程"><a href="#十四、线程与进程" class="headerlink" title="十四、线程与进程"></a>十四、线程与进程</h1><h2 id="14-1-pthread"><a href="#14-1-pthread" class="headerlink" title="14.1 pthread"></a>14.1 pthread</h2><p>在C++中，常见的多线程实现工具是<code>pthread</code>共享库。其头文件是<code>pthread.h</code>，库名是<code>libpthread.so</code>。它不属于标准库行列，在编译时需要指定共享库。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ thread.cpp -lpthread -o thread</span><br></pre></td></tr></table></figure></p>
<ol>
<li><p>线程的创建</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_create</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">pthread_t</span> * newthread,             <span class="comment">// 线程对象指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,        <span class="comment">// 线程属性，没有则为NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">void</span> *(* start_routine) (<span class="type">void</span> *),  <span class="comment">// 线程调用的函数指针，限定void*参数和void*返回值，便于通配。</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">void</span> * arg                         <span class="comment">// 调用函数的实参，同样必须转为void*</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>
<p>pthread_create方法返回值类似于main方法的含义，正常创建返回0，否则返回非0数字。</p>
</li>
<li><p>线程的终止</p>
</li>
</ol>
<p>线程的终止可以分为线程的中途终止和完毕终止。完毕终止指的是执行完了线程执行函数<code>start_routine</code>后释放线程资源，关闭线程。这个过程是自动的，不用程序员操作。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">pthread_exit</span> <span class="params">(<span class="type">void</span> *__retval)</span></span></span><br></pre></td></tr></table></figure><br>pthread_exit方法在线程中主动调用，可以中途终止线程，但不会释放线程资源。<code>__retval</code>参数是线程终止的返回值。值得一提的是，倘若在主线程中最后使用pthread_exit退出，那么主线程不会终止整个进程（这个过程必须是完毕终止才行）。这一特性可以用来维持持久运行的子线程存在。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> THREAD_NUM</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREAD_NUM 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">print</span><span class="params">(<span class="type">void</span>* args)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; (<span class="type">char</span>*)args;</span><br><span class="line">	<span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Sleep\n&quot;</span>;</span><br><span class="line">	<span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//后面部分不会被执行，线程已经终止</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Exit\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="type">pthread_t</span> tids[THREAD_NUM];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; THREAD_NUM; i++) &#123;</span><br><span class="line">		<span class="type">int</span> status = <span class="built_in">pthread_create</span>(&amp;tids[i], <span class="literal">NULL</span>, print, (<span class="type">void</span>*)<span class="string">&quot;Hello world\n&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (status) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Create thread error occur!&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输出信息</span><br><span class="line">Hello world</span><br><span class="line">Hello world</span><br><span class="line">Sleep</span><br><span class="line">Sleep</span><br></pre></td></tr></table></figure><br>上述程序例子中，最终输出没有”Exit”，因为已经中途退出了。倘若没有main方法最后的<code>pthread_exit(NULL)</code>退出主线程，那么输出也没有”Sleep”，因为进程已经随着主线程结束而销毁。这里用了sleep方法来延长子线程，它是声明在<code>unistd.h</code>中的Linux提供的线程休眠API。</p>
<ol>
<li>线程的通讯连接</li>
</ol>
<p><code>extern int pthread_join (pthread_t th, void **thread_return)</code></p>
<p>在学习java多线程时，我们知道其Thread类提供了join方法来进行线程间连接，这里也是类似的提供了<code>pthread_join</code>方法，它的作用在于让当前线程等待特定线程的完成。<code>th</code>参数是线程对象，thread_return则是返回值。</p>
<p>将前述例子修改一下主函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="type">pthread_t</span> tids[THREAD_NUM];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; THREAD_NUM; i++) &#123;</span><br><span class="line">		<span class="type">int</span> status = <span class="built_in">pthread_create</span>(&amp;tids[i], <span class="literal">NULL</span>, print, (<span class="type">void</span>*)<span class="string">&quot;Hello world\n&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (status) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Create thread error occur!&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; THREAD_NUM; i++) &#123;</span><br><span class="line">		<span class="built_in">pthread_join</span>(tids[i], <span class="literal">NULL</span>);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; finished!\n&quot;</span>; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输出内容</span><br><span class="line">Hello world</span><br><span class="line">Hello world</span><br><span class="line">Sleep</span><br><span class="line">Sleep</span><br><span class="line">Thread 0 finished!</span><br><span class="line">Thread 1 finished!</span><br></pre></td></tr></table></figure><br>可以看到<code>pthread_join</code>很好地实现了前面<code>pthread_exit</code>的作用，而且这里是让主线程主动等待子线程的结束。这是多线程任务处理的关键。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] Rogers C, Jesse L.译者:周进、裴强.C++入门经典（第六版）[M].人民邮电出版社.北京:2016.</p>
<p>[2] <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d19fc8447eaa">简书-我理解的右值引用、移动语义和完美转发</a></p>
<p>[3] <a target="_blank" rel="noopener" href="https://blog.csdn.net/kbyte/article/details/2927650">CSDN-cl命令参数详细介绍（转）</a></p>
<p>[4] <a target="_blank" rel="noopener" href="https://blog.csdn.net/surgewong/article/details/39236707">CSDN-gcc/g++ 链接库的编译与链接</a></p>
<p>[5] Stanley B.L, Josee L, Barbara.E.M.译者：王刚，杨巨峰.C++ Primer中文版（第5版）[M].电子工业出版社.北京:2013.</p>
<p>[6] <a target="_blank" rel="noopener" href="https://blog.csdn.net/iteye_11500/article/details/81687267">CSDN-关于Dll中导出string的问题</a></p>
<p>[7] <a target="_blank" rel="noopener" href="https://www.it1352.com/497257.html">IT屋-C ++传递std :: string通过引用dll中的函数</a></p>
<p>[8] <a target="_blank" rel="noopener" href="https://www.runoob.com/cplusplus/cpp-multithreading.html">菜鸟教程-C++多线程</a></p>
<p>[89] 其他零散而不记得来源的参考资料</p>
</div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-meta">本文作者: </span><span class="post-copyright-info"><a href="mailto:undefined">GCS-ZHN</a></span></div><div class="post-copyright-type"><span class="post-copyright-meta">本文链接: </span><span class="post-copyright-info"><a href="https://gcszhn.top/2021/05/13/cpp/">https://gcszhn.top/2021/05/13/cpp/</a></span></div><div class="post-copyright-notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://gcszhn.top">潇洒记忆</a>！</span></div></div></article><div id="pagination"><div class="prev-post pull-left"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/2022/03/10/java/"><i class="fas fa-angle-left">&nbsp;</i><span>java学习笔记</span></a></div><div class="next-post pull-right"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/2021/03/15/cython/"><span>Cython学习笔记</span><span>&nbsp;</span><i class="fas fa-angle-right"></i></a></div></div><!--div!= paginator()--></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-file-o"></i></span><span id="busuanzi_value_page_pv"></span><span></span></div><div class="copyright">&copy;2017 ～ 2024 By GCS-ZHN</div><a href="https://beian.miit.gov.cn/" target="_blank">&nbsp; 浙ICP备2022014039号</a></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--></body></html>